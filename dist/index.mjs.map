{"version":3,"sources":["../src/CustomerSupportChatWidget.tsx","../src/transports/Transport.ts","../src/transports/PollingTransport.ts","../src/transports/WebSocketTransport.ts","../src/plugins/BaconPlugin.ts","../src/plugins/PluginProvider.tsx","../src/messages/registry.tsx","../src/plugins/examples.ts","../src/conversations/ConversationDataService.ts","../src/conversations/ConversationSidebar.tsx","../src/conversations/useConversationFeed.ts"],"sourcesContent":["// src/CustomerSupportChatWidget.tsx\n// A minimal-but-complete customer service chat widget in React + TypeScript.\n// - Floating launcher button\n// - Expandable chat panel\n// - Session persistence via localStorage\n// - Calls a configurable backend chat API endpoint\n// - Simple message list with typing indicator and error handling\n\nimport React, { useEffect, useState, useRef, FormEvent, useMemo } from \"react\";\nimport \"./CustomerSupportChatWidget.css\";\nimport { PollingTransport, PollingTransportOptions } from \"./transports/PollingTransport\";\nimport {\n  Transport,\n  TransportFactory,\n  TransportState,\n  TransportOptions,\n} from \"./transports/Transport\";\nimport { WebSocketTransport, WebSocketTransportOptions } from \"./transports/WebSocketTransport\";\nimport { BaconPlugin, PluginRunner } from \"./plugins/BaconPlugin\";\nimport { PluginProvider } from \"./plugins/PluginProvider\";\nimport {\n  MessageComponentRegistry,\n  defaultMessageRegistry,\n  RichMessagePayload,\n  RichMessageType,\n} from \"./messages/registry\";\n\n/**\n * Represents who sent a given chat message.\n */\nexport type SenderType = \"user\" | \"bot\";\n\n/**\n * A single chat message in the widget.\n */\nexport interface ChatMessage {\n  id: string;\n  sender: SenderType;\n  text: string;\n  createdAt: string; // ISO string for potential analytics / sorting\n  fileUrl?: string;\n  fileName?: string;\n  metadata?: Record<string, unknown>;\n  type?: RichMessageType;\n  payload?: RichMessagePayload;\n}\n\n/**\n * Shape of the backend chat API request.\n * Adjust this to match your backend contract.\n */\nexport interface ChatApiRequest {\n  sessionId: string;\n  message: string;\n  metadata?: Record<string, unknown>;\n  /**\n   * Optional identifier to help backend look up CRM records.\n   * Example: { email: \"user@example.com\" }.\n   */\n  userIdentifier?: Record<string, string>;\n}\n\n/**\n * Shape of the backend chat API response.\n * Adjust this to match your backend contract.\n */\nexport interface ChatApiResponse {\n  reply: string;\n  // You can add more fields here (e.g., topic, suggestedActions, etc.)\n}\n\n/**\n * Props for the CustomerSupportChatWidget component.\n */\nexport interface CustomerSupportChatWidgetProps {\n  /**\n   * Base URL for the chat backend.\n   * Example: \"/api/chat\" or \"https://api.yourdomain.com/chat\".\n   */\n  apiUrl: string;\n  uploadUrl?: string;\n\n  /**\n   * Optional brand or client name to show in header.\n   * Example: \"ClientCo Support\".\n   */\n  title?: string;\n\n  /**\n   * Optional object with known user identifiers (e.g., logged-in user).\n   * This will be sent to the backend so it can search/review the CRM.\n   * Example: { email: \"user@example.com\", phone: \"+15551234567\" }.\n   */\n  userIdentifier?: Record<string, string>;\n\n  /**\n   * Primary accent color for the widget (CSS color value).\n   * Used for header background and launcher button.\n   */\n  primaryColor?: string;\n\n  /**\n   * Optional flag to start with the chat panel open.\n   */\n  defaultOpen?: boolean;\n\n  /**\n   * Optional welcome/intro message that appears when a session is first created\n   * and no other history exists. Useful for surfacing admin-configured greetings\n   * so users always see the expected onboarding copy.\n   */\n  welcomeMessage?: string;\n\n  /**\n   * Optional polling interval (ms) to sync messages from the server.\n   * Defaults to 3000ms. Set to 0 to disable.\n   */\n  pollIntervalMs?: number;\n\n  /**\n   * Optional transport selector. Defaults to \"polling\" to preserve the\n   * previous fetch-based behavior, but can be set to \"websocket\" or a custom\n   * TransportFactory for enterprise deployments (e.g., mutual TLS gateways,\n   * message buses, or proprietary network stacks).\n   */\n  transport?: \"polling\" | \"websocket\" | TransportFactory;\n\n  /**\n   * Extended configuration passed directly to transports. This supports\n   * hardened defaults like TLS-only URLs, auth token injection, rate limits,\n   * or socket.io factories without bloating the public API surface. Values\n   * here override the top-level props where applicable.\n   */\n  transportOptions?: Partial<PollingTransportOptions & WebSocketTransportOptions>;\n\n  /**\n   * Optional plugins that can extend the widget lifecycle with observability,\n   * retries, metadata injection, or UI analytics. Plugins are executed in\n   * array order with isolation guarantees and never mutate upstream objects in\n   * place.\n   */\n  plugins?: BaconPlugin[];\n\n  /**\n   * Optional registry to control how rich message types render inside the widget.\n   */\n  messageRegistry?: MessageComponentRegistry;\n}\n\n/**\n * Local storage key to persist the chat session ID across page loads.\n */\nconst SESSION_STORAGE_KEY = \"cs_chat_session_id_v1\";\n\n/**\n * Simple helper to create a session ID.\n * Uses crypto.randomUUID when available, falls back to a timestamp-based ID.\n */\nfunction createSessionId(): string {\n  if (typeof crypto !== \"undefined\" && \"randomUUID\" in crypto) {\n    return crypto.randomUUID();\n  }\n  return `session_${Date.now()}_${Math.random().toString(16).slice(2)}`;\n}\n\n/**\n * Retrieves or creates a persistent session ID stored in localStorage.\n */\nfunction getOrCreateSessionId(): string {\n  try {\n    const existing = window.localStorage.getItem(SESSION_STORAGE_KEY);\n    if (existing) return existing;\n\n    const newId = createSessionId();\n    window.localStorage.setItem(SESSION_STORAGE_KEY, newId);\n    return newId;\n  } catch {\n    // If localStorage fails (e.g., disabled), just return a fresh ID each time.\n    return createSessionId();\n  }\n}\n\n/**\n * Main customer support chat widget component.\n */\nexport const CustomerSupportChatWidget: React.FC<\n  CustomerSupportChatWidgetProps\n> = ({\n  apiUrl,\n  title = \"Support\",\n  userIdentifier,\n  primaryColor = \"#2563eb\", // Tailwind-ish blue-600\n  defaultOpen = false,\n  uploadUrl,\n  pollIntervalMs = 3000,\n  welcomeMessage,\n  transport = \"polling\",\n  transportOptions,\n  plugins = [],\n  messageRegistry,\n}) => {\n  const [isOpen, setIsOpen] = useState<boolean>(defaultOpen);\n  const [sessionId, setSessionId] = useState<string | null>(null);\n  const [messages, setMessages] = useState<ChatMessage[]>([]);\n  const [inputText, setInputText] = useState<string>(\"\");\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const [transportInstance, setTransportInstance] = useState<Transport | null>(null);\n  const [connectionState, setConnectionState] = useState<TransportState>(\"idle\");\n  const transportOverrides = useMemo(\n    () => transportOptions || {},\n    [transportOptions],\n  );\n  const registry = useMemo(\n    () => messageRegistry || defaultMessageRegistry,\n    [messageRegistry],\n  );\n  const messagesEndRef = useRef<HTMLDivElement | null>(null);\n  const fileInputRef = useRef<HTMLInputElement | null>(null);\n  const pluginRunner = useMemo(\n    () =>\n      new PluginRunner(plugins, {\n        apiUrl,\n        sessionId: sessionId ?? null,\n        transportKind: typeof transport === \"string\" ? transport : \"custom\",\n        userIdentifier,\n        isOpen,\n      }),\n    [plugins],\n  );\n  const pluginContext = useMemo(\n    () => ({\n      apiUrl,\n      sessionId,\n      transportKind: typeof transport === \"string\" ? transport : \"custom\",\n      userIdentifier,\n      isOpen,\n    }),\n    [apiUrl, sessionId, transport, userIdentifier, isOpen],\n  );\n\n  useEffect(() => {\n    pluginRunner.updateContext({\n      apiUrl,\n      sessionId,\n      transportKind: typeof transport === \"string\" ? transport : \"custom\",\n      userIdentifier,\n      isOpen,\n    });\n  }, [pluginRunner, apiUrl, sessionId, transport, userIdentifier, isOpen]);\n\n  useEffect(() => {\n    void pluginRunner.init();\n    void pluginRunner.notifyMount();\n    return () => {\n      void pluginRunner.notifyUnmount();\n    };\n  }, [pluginRunner]);\n\n  useEffect(() => {\n    void pluginRunner.notifyOpen(isOpen);\n  }, [pluginRunner, isOpen]);\n\n  /**\n   * On mount, ensure we have a stable sessionId.\n   */\n  useEffect(() => {\n    const id = getOrCreateSessionId();\n    setSessionId(id);\n  }, []);\n\n  /**\n   * Add a one-time welcome message when the session is initialized and no\n   * history exists. This stays purely client-side so it never competes with\n   * server-sent messages and mirrors the admin-configured greeting.\n   */\n  useEffect(() => {\n    if (!welcomeMessage) return;\n    if (!sessionId) return;\n    if (messages.length > 0) return;\n    addMessage(\"bot\", welcomeMessage);\n  }, [welcomeMessage, sessionId, messages.length]);\n\n  /**\n   * Automatically scroll to the bottom when messages change.\n   */\n  useEffect(() => {\n    if (messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({ behavior: \"smooth\" });\n    }\n  }, [messages, isOpen]);\n\n  /**\n   * Hydrate the transport layer and keep it pinned to the component lifecycle.\n   * WebSocket transports will automatically reconnect with backoff; polling\n   * transports keep the legacy behavior of periodic fetches. If WebSockets\n   * are unavailable (CSP, proxies, or old browsers), the widget gracefully\n   * falls back to polling with the same defaults as before.\n   */\n  useEffect(() => {\n    if (!sessionId) return;\n    const baseOptions: TransportOptions = {\n      apiUrl,\n      sessionId,\n      userIdentifier,\n      uploadUrl,\n      authToken: transportOverrides?.authToken,\n      headers: transportOverrides?.headers,\n      log: transportOverrides?.log,\n    };\n\n    const buildTransport = (): Transport => {\n      if (typeof transport === \"function\") {\n        return transport(baseOptions);\n      }\n      if (transport === \"websocket\") {\n        try {\n          return new WebSocketTransport({\n            ...baseOptions,\n            ...transportOverrides,\n          } as WebSocketTransportOptions);\n        } catch (err) {\n          console.warn(\"WebSocket unavailable, falling back to polling\", err);\n        }\n      }\n      return new PollingTransport({\n        ...baseOptions,\n        ...transportOverrides,\n        pollIntervalMs: transportOverrides?.pollIntervalMs ?? pollIntervalMs,\n      } as PollingTransportOptions);\n    };\n\n    const instance = buildTransport();\n    instance.setEventHandlers({\n      onOpen: () => {\n        setConnectionState(\"open\");\n        void pluginRunner.notifyConnection({ state: \"open\" });\n      },\n      onClose: (reason) => {\n        setConnectionState(\"closed\");\n        void pluginRunner.notifyConnection({ state: \"closed\", reason });\n        if (reason) setError(`Connection closed: ${reason}`);\n      },\n      onError: (err) => {\n        setConnectionState(\"error\");\n        void pluginRunner.notifyConnection({ state: \"error\", reason: err.message });\n        setError(err.message);\n      },\n      onMessage: async (incoming) => {\n        const list = Array.isArray(incoming) ? incoming : [incoming];\n        const processed = await pluginRunner.processMessages(list);\n        setMessages((prev) => {\n          if (Array.isArray(incoming)) return processed;\n          return [...prev, ...processed];\n        });\n      },\n      onTelemetry: (event) => {\n        transportOverrides?.log?.(\"transport_event\", event as any);\n        void pluginRunner.notifyTelemetry(event as any);\n      },\n    });\n    void instance.connect();\n    void pluginRunner.notifyConnection({ state: \"connecting\" });\n    setTransportInstance(instance);\n\n    return () => {\n      void instance.disconnect(\"component_unmounted\");\n    };\n  }, [sessionId, apiUrl, userIdentifier, uploadUrl, pollIntervalMs, transport, transportOverrides]);\n\n  /**\n   * Adds a message to local state.\n   */\n  const addMessage = (sender: SenderType, text: string, extra?: Partial<ChatMessage>) => {\n    const newMessage: ChatMessage = {\n      id: `${sender}_${Date.now()}_${Math.random().toString(16).slice(2)}`,\n      sender,\n      text,\n      createdAt: new Date().toISOString(),\n      ...extra,\n    };\n    setMessages((prev) => [...prev, newMessage]);\n  };\n\n  const sendText = async (raw: string) => {\n    if (!raw.trim() || !sessionId || isLoading) return;\n\n    const trimmed = raw.trim();\n\n    // Optimistically add the user message.\n    addMessage(\"user\", trimmed, { type: \"text\" });\n    setInputText(\"\");\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const payload: ChatApiRequest = {\n        sessionId,\n        message: trimmed,\n        userIdentifier,\n      };\n\n      const data = await pluginRunner.send(payload, dispatchPayload);\n\n      if (data?.reply) {\n        addMessage(\"bot\", data.reply || \"Iâ€™m sorry, I didnâ€™t receive a response.\", { type: \"text\" });\n      }\n    } catch (err) {\n      console.error(\"Chat send error:\", err);\n      setError(\n        \"I ran into a problem reaching our servers. Please try again in a moment.\",\n      );\n      addMessage(\n        \"bot\",\n        \"Iâ€™m having trouble reaching the support system right now. Please try again shortly or contact us via another channel.\",\n      );\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const dispatchPayload = async (payload: ChatApiRequest): Promise<ChatApiResponse | void> => {\n    if (transportInstance) {\n      return transportInstance.send(payload);\n    }\n    const response = await fetch(apiUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(payload),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Chat API responded with status ${response.status}: ${response.statusText}`);\n    }\n\n    return (await response.json()) as ChatApiResponse;\n  };\n\n  /**\n   * Handles form submission (user sends a message).\n   */\n  const handleSubmit = async (event: FormEvent) => {\n    event.preventDefault();\n    if (!inputText.trim() || !sessionId || isLoading) return;\n    const pending = inputText;\n    await sendText(pending);\n  };\n\n  const handleFileSelected = async (file: File | null) => {\n    if (!file || !sessionId) return;\n    setIsLoading(true);\n    setError(null);\n    try {\n      if (transportInstance?.sendFile) {\n        const response = await transportInstance.sendFile(file, {\n          ...(userIdentifier || {}),\n        });\n        if (response) {\n          setMessages((prev) => [...prev, response]);\n          return;\n        }\n      }\n\n      const form = new FormData();\n      form.append(\"sessionId\", sessionId);\n      if (userIdentifier) {\n        for (const [k, v] of Object.entries(userIdentifier)) {\n          form.append(`user_${k}`, String(v));\n        }\n      }\n      form.append(\"file\", file, file.name);\n\n      let target = uploadUrl;\n      if (!target) {\n        target = apiUrl.endsWith(\"/chat\")\n          ? apiUrl.replace(/\\/chat$/, \"/upload\")\n          : apiUrl.replace(/\\/$/, \"\") + \"/upload\";\n      }\n\n      const resp = await fetch(target!, { method: \"POST\", body: form });\n      if (!resp.ok) throw new Error(`Upload failed: ${resp.status}`);\n      let fileUrl: string | undefined;\n      try {\n        const data = await resp.json();\n        fileUrl = data?.files?.[0]?.url;\n      } catch {}\n      const label = `Uploaded file: ${file.name}`;\n      if (fileUrl) {\n        const message: ChatMessage = {\n          id: `user_${Date.now()}_${Math.random().toString(16).slice(2)}`,\n          sender: \"user\",\n          text: label,\n          createdAt: new Date().toISOString(),\n          fileUrl,\n          fileName: file.name,\n        };\n        setMessages((prev) => [...prev, message]);\n      } else {\n        addMessage(\"user\", label);\n      }\n    } catch (e) {\n      console.error(\"upload error\", e);\n      setError(\"We couldn't upload your file. Please try again.\");\n    } finally {\n      setIsLoading(false);\n      if (fileInputRef.current) fileInputRef.current.value = \"\";\n    }\n  };\n\n  const handleQuickReply = async (value: string) => {\n    await sendText(value);\n  };\n\n  /**\n   * Basic header subtitle showing user identifier if available.\n   */\n  const renderSubtitle = () => {\n    if (!userIdentifier)\n      return \"Ask us anything about your account or our services.\";\n    if (userIdentifier.email) return `Signed in as ${userIdentifier.email}`;\n    if (userIdentifier.phone) return `Signed in with ${userIdentifier.phone}`;\n    return \"Ask us anything about your account or our services.\";\n  };\n\n  return (\n    <PluginProvider plugins={plugins} context={pluginContext} runner={pluginRunner}>\n      <div\n        className=\"cs-chat-root\"\n        style={{ [\"--cs-primary\" as any]: primaryColor } as React.CSSProperties}\n      >\n        {/* Floating launcher button */}\n        <button\n          type=\"button\"\n          className=\"cs-chat-launcher\"\n          onClick={() => setIsOpen((prev) => !prev)}\n          aria-label={isOpen ? \"Close support chat\" : \"Open support chat\"}\n        >\n          {/* Simple icon: chat bubble */}\n          <span className=\"cs-chat-launcher-icon\" aria-hidden=\"true\">\n            ðŸ’¬\n          </span>\n        </button>\n\n        {/* Chat panel */}\n        {isOpen && (\n          <div className=\"cs-chat-panel\">\n            <div className=\"cs-chat-header\">\n              <div className=\"cs-chat-header-main\">\n                <div className=\"cs-chat-title\">{title}</div>\n                <div className=\"cs-chat-subtitle\">{renderSubtitle()}</div>\n              </div>\n              <button\n                type=\"button\"\n                className=\"cs-chat-header-close\"\n                onClick={() => setIsOpen(false)}\n                aria-label=\"Close chat\"\n              >\n                âœ•\n              </button>\n            </div>\n\n            <div className=\"cs-chat-body\">\n              {/* Optional error banner */}\n              {error && <div className=\"cs-chat-error\">{error}</div>}\n\n              {/* Messages list */}\n              <div className=\"cs-chat-messages\">\n                {messages.map((msg) => (\n                  <div\n                    key={msg.id}\n                    className={`cs-chat-message cs-chat-message--${msg.sender}`}\n                  >\n                    <div className=\"cs-chat-message-bubble\">\n                      {registry.render(msg, { onQuickReply: handleQuickReply })}\n                    </div>\n                  </div>\n                ))}\n\n                {/* Typing indicator */}\n                {isLoading && (\n                  <div className=\"cs-chat-message cs-chat-message--bot\">\n                    <div className=\"cs-chat-message-bubble cs-chat-typing-indicator\">\n                      <span className=\"cs-dot\" />\n                      <span className=\"cs-dot\" />\n                      <span className=\"cs-dot\" />\n                    </div>\n                  </div>\n                )}\n\n                <div ref={messagesEndRef} />\n              </div>\n            </div>\n\n            <form className=\"cs-chat-input-row\" onSubmit={handleSubmit}>\n              <input\n                ref={fileInputRef}\n                type=\"file\"\n                className=\"cs-chat-file-input\"\n                aria-label=\"Attach file\"\n                onChange={(e) => handleFileSelected(e.target.files?.[0] || null)}\n                style={{ display: \"none\" }}\n              />\n              <button\n                type=\"button\"\n                className=\"cs-chat-attach-button\"\n                onClick={() => fileInputRef.current?.click()}\n                disabled={isLoading || !sessionId}\n                aria-label=\"Attach a file\"\n                title=\"Attach a file\"\n              >\n                ðŸ“Ž\n              </button>\n              <input\n                type=\"text\"\n                className=\"cs-chat-input\"\n                placeholder=\"Type your message...\"\n                value={inputText}\n                onChange={(e) => setInputText(e.target.value)}\n                disabled={isLoading || !sessionId}\n              />\n              <button\n                type=\"submit\"\n                className=\"cs-chat-send-button\"\n                disabled={isLoading || !sessionId || !inputText.trim()}\n              >\n                Send\n              </button>\n            </form>\n          </div>\n        )}\n      </div>\n    </PluginProvider>\n  );\n};\n","import { ChatApiRequest, ChatApiResponse, ChatMessage } from \"../CustomerSupportChatWidget\";\n\n/**\n * Core transport lifecycle states. The widget uses these to emit UX hints\n * (e.g., reconnecting banners) and to avoid sending messages while a\n * connection is offline.\n */\nexport type TransportState = \"idle\" | \"connecting\" | \"open\" | \"closed\" | \"error\";\n\n/**\n * Lightweight telemetry event emitted by transports for observability.\n * This intentionally stays generic so it can be forwarded to your preferred\n * logging/metrics system without pulling heavy dependencies into the widget\n * bundle.\n */\nexport interface TransportTelemetryEvent {\n  name: string;\n  detail?: Record<string, unknown>;\n  at: number;\n}\n\n/**\n * Event hooks that the widget provides to each transport implementation.\n * Implementations must call these hooks rather than touching UI state to\n * keep the transport layer framework-agnostic and easily testable.\n */\nexport interface TransportEventHandlers {\n  onOpen?: () => void;\n  onClose?: (reason?: string) => void;\n  onError?: (error: Error) => void;\n  /**\n   * Called when the transport receives new messages from the server. Most\n   * transports will emit the server's canonical list for simplicity, but\n   * they may also emit single deltas (e.g., WebSocket push messages). The\n   * widget merges appropriately.\n   */\n  onMessage?: (message: ChatMessage | ChatMessage[]) => void;\n  onTelemetry?: (event: TransportTelemetryEvent) => void;\n}\n\n/**\n * Common options available to all transports. Individual transports can\n * extend this with additional knobs (e.g., polling interval or socket\n * configuration), but keeping a single shared shape makes it easier for the\n * widget to swap transports transparently.\n */\nexport interface TransportOptions {\n  apiUrl: string;\n  sessionId: string;\n  userIdentifier?: Record<string, string>;\n  /** Optional upload endpoint for file-based channels. */\n  uploadUrl?: string;\n  /** Optional bearer token or other credential material. */\n  authToken?: string;\n  /** Static headers to add to every request. */\n  headers?: Record<string, string>;\n  /** Optional logger for production hardening. */\n  log?: (message: string, detail?: Record<string, unknown>) => void;\n}\n\n/**\n * Contract for all widget transports. Implementations should be resilient\n * (retry/backoff), side-effect free outside of provided hooks, and able to\n * cleanly tear down timers/sockets on disconnect to avoid leaks.\n */\nexport interface Transport {\n  readonly name: string;\n  readonly state: TransportState;\n  setEventHandlers(handlers: TransportEventHandlers): void;\n  connect(): Promise<void>;\n  disconnect(reason?: string): Promise<void>;\n  /**\n   * Send a user text payload to the server. The transport returns whatever\n   * the backend responds with so the caller can surface optimistic updates.\n   */\n  send(payload: ChatApiRequest): Promise<ChatApiResponse | void>;\n  /** Optional binary upload pathway for richer channels. */\n  sendFile?: (\n    file: File,\n    metadata?: Record<string, string>,\n  ) => Promise<ChatMessage | undefined>;\n}\n\n/** Factory signature the widget can use to defer transport creation. */\nexport type TransportFactory = (options: TransportOptions) => Transport;\n\n/**\n * Helper for exponential backoff with jitter. Keeps transport implementations\n * lean and consistent.\n */\nexport function computeBackoff(\n  attempt: number,\n  baseMs: number,\n  maxMs: number,\n): number {\n  const capped = Math.min(maxMs, baseMs * Math.pow(2, attempt));\n  const jitter = Math.random() * 0.25 * capped;\n  return Math.round(capped * 0.75 + jitter);\n}\n","import {\n  ChatApiRequest,\n  ChatApiResponse,\n  ChatMessage,\n} from \"../CustomerSupportChatWidget\";\nimport {\n  Transport,\n  TransportEventHandlers,\n  TransportOptions,\n  TransportState,\n  computeBackoff,\n} from \"./Transport\";\n\nexport interface PollingTransportOptions extends TransportOptions {\n  pollIntervalMs?: number;\n  /** Optional long-poll timeout to keep connections hot. */\n  longPollTimeoutMs?: number;\n  /** Backoff settings for retry-after-failure. */\n  backoffBaseMs?: number;\n  backoffMaxMs?: number;\n}\n\n/**\n * Polling transport preserves the previous fetch-based behavior while adding\n * structured lifecycle hooks, retry/backoff semantics, and telemetry points.\n * The widget treats this as the default, zero-dependency transport.\n */\nexport class PollingTransport implements Transport {\n  public readonly name = \"polling\" as const;\n  public state: TransportState = \"idle\";\n  private handlers: TransportEventHandlers = {};\n  private timer: ReturnType<typeof setTimeout> | null = null;\n  private stopped = false;\n  private attempt = 0;\n\n  constructor(private options: PollingTransportOptions) {}\n\n  setEventHandlers(handlers: TransportEventHandlers): void {\n    this.handlers = handlers;\n  }\n\n  async connect(): Promise<void> {\n    if (this.state === \"open\" || this.state === \"connecting\") return;\n    this.stopped = false;\n    this.state = \"connecting\";\n    this.handlers.onTelemetry?.({\n      name: \"polling_connect\",\n      at: Date.now(),\n      detail: { apiUrl: this.options.apiUrl },\n    });\n    this.schedulePoll(0);\n  }\n\n  async disconnect(reason?: string): Promise<void> {\n    this.stopped = true;\n    this.state = \"closed\";\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n    this.handlers.onClose?.(reason);\n  }\n\n  async send(payload: ChatApiRequest): Promise<ChatApiResponse | void> {\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      ...this.options.headers,\n    };\n    if (this.options.authToken) {\n      headers[\"Authorization\"] = `Bearer ${this.options.authToken}`;\n    }\n    const response = await fetch(this.options.apiUrl, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(payload),\n    });\n    if (!response.ok) {\n      const error = new Error(\n        `Chat API responded with status ${response.status}: ${response.statusText}`,\n      );\n      this.handlers.onError?.(error);\n      throw error;\n    }\n    const data = (await response.json()) as ChatApiResponse;\n    this.handlers.onTelemetry?.({ name: \"polling_send\", at: Date.now() });\n    return data;\n  }\n\n  async sendFile(\n    file: File,\n    metadata?: Record<string, string>,\n  ): Promise<ChatMessage | undefined> {\n    const form = new FormData();\n    form.append(\"sessionId\", this.options.sessionId);\n    if (metadata) {\n      for (const [k, v] of Object.entries(metadata)) {\n        form.append(k, v);\n      }\n    }\n    form.append(\"file\", file, file.name);\n    const uploadUrl =\n      this.options.uploadUrl || this.options.apiUrl.replace(/\\/chat$/, \"/upload\");\n    const response = await fetch(uploadUrl, { method: \"POST\", body: form });\n    if (!response.ok) {\n      const error = new Error(`Upload failed: ${response.status}`);\n      this.handlers.onError?.(error);\n      throw error;\n    }\n    try {\n      const parsed = await response.json();\n      const url = parsed?.files?.[0]?.url;\n      if (url) {\n        return {\n          id: `user_${Date.now()}_${Math.random().toString(16).slice(2)}`,\n          sender: \"user\",\n          text: `Uploaded file: ${file.name}`,\n          createdAt: new Date().toISOString(),\n          fileUrl: url,\n          fileName: file.name,\n        };\n      }\n    } catch (e) {\n      this.handlers.onTelemetry?.({\n        name: \"polling_upload_parse_failure\",\n        at: Date.now(),\n        detail: { error: (e as Error).message },\n      });\n    }\n    return undefined;\n  }\n\n  private schedulePoll(delay: number) {\n    if (this.stopped) return;\n    this.timer = setTimeout(() => {\n      void this.poll();\n    }, delay);\n  }\n\n  private async poll() {\n    if (this.stopped) return;\n    const interval = this.options.pollIntervalMs ?? 3000;\n    const abort = new AbortController();\n    const timeout = this.options.longPollTimeoutMs ?? interval;\n    const timer = setTimeout(() => abort.abort(), timeout);\n    const messagesUrl = this.options.apiUrl.endsWith(\"/chat\")\n      ? this.options.apiUrl\n      : this.options.apiUrl.replace(/\\/$/, \"\") + \"/chat\";\n    try {\n      const res = await fetch(\n        `${messagesUrl}?sessionId=${encodeURIComponent(this.options.sessionId)}`,\n        {\n          signal: abort.signal,\n          headers: this.buildHeaders(),\n        },\n      );\n      clearTimeout(timer);\n      if (!res.ok) throw new Error(`Polling failed: ${res.status}`);\n      const list = (await res.json()) as ChatMessage[];\n      this.state = \"open\";\n      this.attempt = 0;\n      this.handlers.onOpen?.();\n      this.handlers.onMessage?.(Array.isArray(list) ? list : []);\n      this.handlers.onTelemetry?.({ name: \"polling_tick\", at: Date.now() });\n      this.schedulePoll(interval);\n    } catch (err) {\n      clearTimeout(timer);\n      this.state = \"error\";\n      const detail = err instanceof Error ? err.message : String(err);\n      this.handlers.onError?.(err as Error);\n      this.handlers.onTelemetry?.({\n        name: \"polling_retry_scheduled\",\n        at: Date.now(),\n        detail: { attempt: this.attempt + 1, error: detail },\n      });\n      const delay = computeBackoff(\n        this.attempt++,\n        this.options.backoffBaseMs ?? 1000,\n        this.options.backoffMaxMs ?? 30000,\n      );\n      this.schedulePoll(delay);\n    }\n  }\n\n  private buildHeaders(): Record<string, string> {\n    const headers: Record<string, string> = { ...(this.options.headers || {}) };\n    if (this.options.authToken) {\n      headers[\"Authorization\"] = `Bearer ${this.options.authToken}`;\n    }\n    return headers;\n  }\n}\n","import {\n  ChatApiRequest,\n  ChatApiResponse,\n  ChatMessage,\n} from \"../CustomerSupportChatWidget\";\nimport {\n  Transport,\n  TransportEventHandlers,\n  TransportOptions,\n  TransportState,\n  computeBackoff,\n} from \"./Transport\";\n\nexport interface WebSocketFactory {\n  new (url: string, protocols?: string | string[]): WebSocket;\n}\n\nexport interface SocketIoLikeClient {\n  on(event: string, callback: (...args: any[]) => void): this;\n  off(event: string, callback?: (...args: any[]) => void): this;\n  emit(event: string, payload: unknown): this;\n  close(): void;\n  disconnect(): void;\n  connect(): void;\n}\n\nexport interface WebSocketTransportOptions extends TransportOptions {\n  webSocketUrl?: string;\n  heartbeatMs?: number;\n  backoffBaseMs?: number;\n  backoffMaxMs?: number;\n  /** Optional socket.io client factory to support older proxies. */\n  socketIoFactory?: (url: string, opts?: Record<string, unknown>) => SocketIoLikeClient;\n  /** Override the WebSocket constructor (useful for tests). */\n  webSocketImpl?: WebSocketFactory;\n}\n\n/**\n * WebSocket transport leans on the browser-native WebSocket when available\n * and optionally a socket.io client for environments that need fallback.\n * It prioritizes ordered delivery and reconnect/backoff semantics.\n */\nexport class WebSocketTransport implements Transport {\n  public readonly name = \"websocket\" as const;\n  public state: TransportState = \"idle\";\n  private handlers: TransportEventHandlers = {};\n  private socket: WebSocket | SocketIoLikeClient | null = null;\n  private reconnectAttempt = 0;\n  private heartbeatTimer: ReturnType<typeof setInterval> | null = null;\n  private closedByUser = false;\n  private messageQueue: string[] = [];\n\n  constructor(private options: WebSocketTransportOptions) {}\n\n  setEventHandlers(handlers: TransportEventHandlers): void {\n    this.handlers = handlers;\n  }\n\n  async connect(): Promise<void> {\n    if (this.state === \"open\" || this.state === \"connecting\") return;\n    this.closedByUser = false;\n    this.state = \"connecting\";\n    const url = this.computeUrl();\n    const wsImpl = this.resolveImpl();\n    if (!wsImpl) {\n      throw new Error(\"WebSocket is not available in this environment\");\n    }\n\n    this.handlers.onTelemetry?.({ name: \"ws_connect\", at: Date.now(), detail: { url } });\n    this.socket = new wsImpl(url);\n    this.bindNativeSocket(this.socket as WebSocket);\n  }\n\n  async disconnect(reason?: string): Promise<void> {\n    this.closedByUser = true;\n    this.state = \"closed\";\n    if (this.heartbeatTimer) clearInterval(this.heartbeatTimer);\n    if (!this.socket) return;\n    if (\"close\" in this.socket) {\n      (this.socket as any).close();\n    }\n    if (\"disconnect\" in this.socket) {\n      (this.socket as SocketIoLikeClient).disconnect();\n    }\n    this.handlers.onClose?.(reason);\n  }\n\n  async send(payload: ChatApiRequest): Promise<ChatApiResponse | void> {\n    const envelope = JSON.stringify({\n      type: \"message\",\n      sessionId: this.options.sessionId,\n      userIdentifier: this.options.userIdentifier,\n      payload,\n    });\n    if (this.socket && (this.socket as WebSocket).readyState === WebSocket.OPEN) {\n      (this.socket as WebSocket).send(envelope);\n      return;\n    }\n    if (this.socket && \"emit\" in this.socket) {\n      (this.socket as SocketIoLikeClient).emit(\"message\", envelope);\n      return;\n    }\n    // Queue messages until the connection reopens to preserve ordering.\n    this.messageQueue.push(envelope);\n  }\n\n  async sendFile(\n    file: File,\n    metadata?: Record<string, string>,\n  ): Promise<ChatMessage | undefined> {\n    const envelope = {\n      type: \"file\",\n      sessionId: this.options.sessionId,\n      metadata,\n      name: file.name,\n      size: file.size,\n    };\n    const payload = JSON.stringify(envelope);\n    if (this.socket && (this.socket as WebSocket).readyState === WebSocket.OPEN) {\n      (this.socket as WebSocket).send(payload);\n      (this.socket as WebSocket).send(file);\n    } else if (this.socket && \"emit\" in this.socket) {\n      (this.socket as SocketIoLikeClient).emit(\"file\", { ...envelope, file });\n    } else {\n      this.messageQueue.push(payload);\n    }\n    return undefined;\n  }\n\n  private computeUrl() {\n    if (this.options.webSocketUrl) return this.options.webSocketUrl;\n    // Auto-derive from API URL: https://api.example.com/chat => wss://api.example.com/chat/ws\n    const parsed = new URL(this.options.apiUrl, typeof window !== \"undefined\" ? window.location.href : undefined);\n    parsed.protocol = parsed.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n    parsed.pathname = parsed.pathname.replace(/\\/$/, \"\") + \"/ws\";\n    return parsed.toString();\n  }\n\n  private resolveImpl(): WebSocketFactory | null {\n    if (this.options.socketIoFactory) {\n      // Defer binding until after connect().\n      const factory = this.options.socketIoFactory;\n      // Wrap socket.io client with a WebSocket-compatible shim so the rest of the\n      // class can treat both shapes the same.\n      const shim: WebSocketFactory = class {\n        private client = factory!(\"\");\n        public readyState = WebSocket.CONNECTING;\n        constructor(url: string) {\n          this.client = factory!(url, { transports: [\"websocket\"], withCredentials: true });\n        }\n        close() {\n          this.client.disconnect();\n        }\n        send(payload: string | Blob) {\n          this.client.emit(\"message\", payload);\n        }\n        addEventListener(event: string, cb: (ev: any) => void) {\n          this.client.on(event, cb);\n        }\n        removeEventListener(event: string, cb: (ev: any) => void) {\n          this.client.off(event, cb);\n        }\n        // The widget never relies on other members.\n      } as unknown as WebSocketFactory;\n      return shim;\n    }\n    if (this.options.webSocketImpl) return this.options.webSocketImpl;\n    if (typeof WebSocket !== \"undefined\") return WebSocket;\n    return null;\n  }\n\n  private bindNativeSocket(socket: WebSocket) {\n    socket.addEventListener(\"open\", () => {\n      this.state = \"open\";\n      this.reconnectAttempt = 0;\n      this.handlers.onOpen?.();\n      this.flushQueue();\n      this.startHeartbeat(socket);\n    });\n    socket.addEventListener(\"message\", (event) => {\n      try {\n        const parsed = JSON.parse(event.data as string);\n        if (Array.isArray(parsed)) {\n          this.handlers.onMessage?.(parsed as ChatMessage[]);\n        } else if (parsed?.reply) {\n          this.handlers.onMessage?.([\n            {\n              id: `bot_${Date.now()}`,\n              sender: \"bot\",\n              text: parsed.reply,\n              createdAt: new Date().toISOString(),\n            },\n          ]);\n        } else {\n          this.handlers.onMessage?.(parsed as ChatMessage);\n        }\n      } catch (err) {\n        this.handlers.onError?.(err as Error);\n      }\n    });\n    socket.addEventListener(\"close\", () => {\n      this.state = \"closed\";\n      this.handlers.onClose?.();\n      this.stopHeartbeat();\n      if (!this.closedByUser) {\n        this.scheduleReconnect();\n      }\n    });\n    socket.addEventListener(\"error\", (event) => {\n      this.state = \"error\";\n      this.handlers.onError?.(\n        event instanceof ErrorEvent\n          ? new Error(event.message)\n          : new Error(\"WebSocket error\"),\n      );\n      this.scheduleReconnect();\n    });\n  }\n\n  private startHeartbeat(socket: WebSocket) {\n    const interval = this.options.heartbeatMs ?? 30000;\n    if (interval <= 0) return;\n    this.stopHeartbeat();\n    this.heartbeatTimer = setInterval(() => {\n      if (socket.readyState === WebSocket.OPEN) {\n        socket.send(JSON.stringify({ type: \"ping\", ts: Date.now() }));\n      }\n    }, interval);\n  }\n\n  private stopHeartbeat() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n  }\n\n  private scheduleReconnect() {\n    if (this.closedByUser) return;\n    const delay = computeBackoff(\n      this.reconnectAttempt++,\n      this.options.backoffBaseMs ?? 500,\n      this.options.backoffMaxMs ?? 15000,\n    );\n    this.handlers.onTelemetry?.({\n      name: \"ws_reconnect_scheduled\",\n      at: Date.now(),\n      detail: { attempt: this.reconnectAttempt, delay },\n    });\n    setTimeout(() => {\n      if (!this.closedByUser) {\n        void this.connect();\n      }\n    }, delay);\n  }\n\n  private flushQueue() {\n    if (!this.socket) return;\n    const ws = this.socket as WebSocket;\n    while (this.messageQueue.length && ws.readyState === WebSocket.OPEN) {\n      const next = this.messageQueue.shift();\n      if (next) ws.send(next);\n    }\n  }\n}\n","import { ChatApiRequest, ChatApiResponse, ChatMessage } from \"../CustomerSupportChatWidget\";\n\n/**\n * Runtime context shared with every plugin invocation. Plugins must treat this\n * structure as immutable and should never mutate nested objects in place;\n * instead, return an updated copy when changes are required. The runner will\n * deep-clone payloads/messages between plugins to prevent accidental\n * cross-plugin mutation.\n */\nexport interface PluginRuntimeContext {\n  readonly apiUrl: string;\n  readonly sessionId: string | null;\n  readonly transportKind: string;\n  readonly userIdentifier?: Record<string, string>;\n  readonly isOpen: boolean;\n}\n\nexport interface BeforeSendResult {\n  payload?: ChatApiRequest;\n  /** Allows a plugin to short-circuit network IO entirely. */\n  response?: ChatApiResponse | void;\n  /** If true, the send operation is aborted without surfacing an error. */\n  abort?: boolean;\n}\n\nexport interface SendErrorResult {\n  /**\n   * Request a retry. The runner caps retries to avoid infinite loops; callers\n   * can optionally provide a delay or mutated payload for the retry attempt.\n   */\n  retry?: boolean;\n  waitMs?: number;\n  payload?: ChatApiRequest;\n}\n\nexport interface IncomingMessageResult {\n  messages?: ChatMessage[];\n}\n\nexport interface ConnectionEventMeta {\n  state: \"idle\" | \"connecting\" | \"open\" | \"closed\" | \"error\";\n  reason?: string;\n}\n\nexport interface BaconPlugin {\n  /** Stable identifier for debugging and telemetry. */\n  name: string;\n\n  onInit?(ctx: PluginRuntimeContext): void | Promise<void>;\n  onWidgetMount?(ctx: PluginRuntimeContext): void | Promise<void>;\n  onWidgetUnmount?(ctx: PluginRuntimeContext): void | Promise<void>;\n  onWidgetOpen?(ctx: PluginRuntimeContext): void | Promise<void>;\n  onWidgetClose?(ctx: PluginRuntimeContext): void | Promise<void>;\n\n  onConnectionEvent?(meta: ConnectionEventMeta, ctx: PluginRuntimeContext): void | Promise<void>;\n  onBeforeSend?(payload: ChatApiRequest, ctx: PluginRuntimeContext): void | BeforeSendResult | Promise<void | BeforeSendResult>;\n  onAfterSend?(payload: ChatApiRequest, response: ChatApiResponse | void, ctx: PluginRuntimeContext): void | Promise<void>;\n  onSendError?(error: unknown, payload: ChatApiRequest, ctx: PluginRuntimeContext): void | SendErrorResult | Promise<void | SendErrorResult>;\n  onMessages?(messages: ChatMessage[], ctx: PluginRuntimeContext): void | IncomingMessageResult | Promise<void | IncomingMessageResult>;\n  onTelemetry?(event: Record<string, unknown>, ctx: PluginRuntimeContext): void | Promise<void>;\n}\n\n/**\n * Deep clone helper that prefers structuredClone when available for safety. The\n * runner clones payloads before handing them to plugins to ensure no plugin can\n * mutate another plugin's view of the data.\n */\nexport function cloneSafe<T>(value: T): T {\n  if (typeof structuredClone === \"function\") return structuredClone(value);\n  return JSON.parse(JSON.stringify(value)) as T;\n}\n\nconst MAX_RETRIES = 2;\n\nexport class AbortSendError extends Error {\n  constructor() {\n    super(\"send_aborted_by_plugin\");\n  }\n}\n\n/**\n * Central orchestrator for plugin execution. Each hook is executed serially to\n * preserve ordering guarantees, and every invocation is wrapped in a try/catch\n * so plugin failures are isolated and reported without impacting the caller.\n */\nexport class PluginRunner {\n  constructor(private plugins: BaconPlugin[], private ctx: PluginRuntimeContext) {}\n\n  updateContext(partial: Partial<PluginRuntimeContext>) {\n    this.ctx = { ...this.ctx, ...partial };\n  }\n\n  async init() {\n    await this.run(\"onInit\");\n  }\n\n  async notifyMount() {\n    await this.run(\"onWidgetMount\");\n  }\n\n  async notifyUnmount() {\n    await this.run(\"onWidgetUnmount\");\n  }\n\n  async notifyOpen(isOpen: boolean) {\n    await this.run(isOpen ? \"onWidgetOpen\" : \"onWidgetClose\");\n  }\n\n  async notifyConnection(meta: ConnectionEventMeta) {\n    await this.run(\"onConnectionEvent\", meta);\n  }\n\n  async notifyTelemetry(event: Record<string, unknown>) {\n    await this.run(\"onTelemetry\", cloneSafe(event));\n  }\n\n  async processMessages(incoming: ChatMessage[]): Promise<ChatMessage[]> {\n    let current = cloneSafe(incoming);\n    for (const plugin of this.plugins) {\n      if (!plugin.onMessages) continue;\n      try {\n        const next = await plugin.onMessages(cloneSafe(current), this.ctx);\n        if (next?.messages) current = cloneSafe(next.messages);\n      } catch (err) {\n        console.warn(`[plugin:${plugin.name}] onMessages failed`, err);\n      }\n    }\n    return current;\n  }\n\n  /**\n   * Executes the send pipeline with plugin hooks and retry semantics. The\n   * caller provides the actual network send implementation so this runner stays\n   * transport-agnostic.\n   */\n  async send(\n    payload: ChatApiRequest,\n    dispatcher: (payload: ChatApiRequest) => Promise<ChatApiResponse | void>,\n  ): Promise<ChatApiResponse | void> {\n    let currentPayload = cloneSafe(payload);\n    let retries = 0;\n\n    const applyBeforeSend = async () => {\n      let working = currentPayload;\n      for (const plugin of this.plugins) {\n        if (!plugin.onBeforeSend) continue;\n        try {\n          const result = await plugin.onBeforeSend(cloneSafe(working), this.ctx);\n          if (result?.abort) throw new AbortSendError();\n          if (result?.payload) working = cloneSafe(result.payload);\n          if (result?.response !== undefined) return { shortCircuit: result.response };\n        } catch (err) {\n          if (err instanceof AbortSendError) throw err;\n          console.warn(`[plugin:${plugin.name}] onBeforeSend failed`, err);\n        }\n      }\n      currentPayload = working;\n      return { shortCircuit: undefined as ChatApiResponse | void | undefined };\n    };\n\n    while (retries <= MAX_RETRIES) {\n      let before;\n      try {\n        before = await applyBeforeSend();\n      } catch (err) {\n        if (err instanceof AbortSendError) {\n          await this.run(\"onAfterSend\", currentPayload, undefined);\n          return;\n        }\n        throw err;\n      }\n      if (before.shortCircuit !== undefined) {\n        await this.run(\"onAfterSend\", currentPayload, before.shortCircuit);\n        return before.shortCircuit;\n      }\n\n      try {\n        const response = await dispatcher(currentPayload);\n        await this.run(\"onAfterSend\", currentPayload, response);\n        return response;\n      } catch (err) {\n        if (err instanceof AbortSendError) throw err;\n        const retryDirective = await this.handleSendError(err, currentPayload);\n        if (retryDirective.retry && retries < MAX_RETRIES) {\n          retries += 1;\n          if (retryDirective.payload) currentPayload = cloneSafe(retryDirective.payload);\n          if (retryDirective.waitMs && retryDirective.waitMs > 0) {\n            await new Promise((resolve) => setTimeout(resolve, retryDirective.waitMs));\n          }\n          continue;\n        }\n        throw err;\n      }\n    }\n    throw new Error(\"Max retries exceeded\");\n  }\n\n  private async handleSendError(error: unknown, payload: ChatApiRequest): Promise<SendErrorResult> {\n    let directive: SendErrorResult = {};\n    for (const plugin of this.plugins) {\n      if (!plugin.onSendError) continue;\n      try {\n        const next = await plugin.onSendError(error, cloneSafe(payload), this.ctx);\n        if (next?.retry) directive = { ...directive, ...next };\n      } catch (err) {\n        console.warn(`[plugin:${plugin.name}] onSendError failed`, err);\n      }\n    }\n    return directive;\n  }\n\n  private async run(\n    hook: keyof BaconPlugin,\n    ...args: Array<unknown>\n  ): Promise<void> {\n    for (const plugin of this.plugins) {\n      const fn = plugin[hook] as ((...a: unknown[]) => unknown) | undefined;\n      if (!fn) continue;\n      try {\n        await fn.apply(plugin, [...args, this.ctx]);\n      } catch (err) {\n        console.warn(`[plugin:${plugin.name}] ${String(hook)} failed`, err);\n      }\n    }\n  }\n}\n","import React, { createContext, useContext, useMemo } from \"react\";\nimport { BaconPlugin, PluginRunner, PluginRuntimeContext } from \"./BaconPlugin\";\n\nconst PluginRunnerContext = createContext<PluginRunner | null>(null);\n\nexport interface PluginProviderProps {\n  plugins?: BaconPlugin[];\n  context: PluginRuntimeContext;\n  runner?: PluginRunner;\n  children: React.ReactNode;\n}\n\nexport const PluginProvider: React.FC<PluginProviderProps> = ({\n  plugins = [],\n  context,\n  runner: runnerProp,\n  children,\n}) => {\n  const computed = useMemo(\n    () => runnerProp ?? new PluginRunner(plugins, context),\n    [runnerProp, plugins, context],\n  );\n  return <PluginRunnerContext.Provider value={computed}>{children}</PluginRunnerContext.Provider>;\n};\n\nexport function usePluginRunner(): PluginRunner | null {\n  return useContext(PluginRunnerContext);\n}\n","import React from \"react\";\nimport { ChatMessage } from \"../CustomerSupportChatWidget\";\n\nexport type RichMessageType =\n  | \"text\"\n  | \"card\"\n  | \"product\"\n  | \"survey\"\n  | \"quick_replies\"\n  | (string & {});\n\nexport interface RichMessagePayload {\n  title?: string;\n  body?: string;\n  imageUrl?: string;\n  actions?: { label: string; value: string; url?: string }[];\n  data?: Record<string, unknown>;\n}\n\nexport type MessageRenderer = (\n  message: ChatMessage,\n  helpers: { onQuickReply?: (value: string) => void },\n) => React.ReactNode;\n\nexport class MessageComponentRegistry {\n  private renderers = new Map<string, MessageRenderer>();\n\n  register(type: string, renderer: MessageRenderer) {\n    this.renderers.set(type, renderer);\n  }\n\n  render(message: ChatMessage, helpers: { onQuickReply?: (value: string) => void } = {}) {\n    const renderer = message.type ? this.renderers.get(message.type) : undefined;\n    if (renderer) return renderer(message, helpers);\n    return this.renderFallback(message);\n  }\n\n  private renderFallback(message: ChatMessage) {\n    if (message.fileUrl) {\n      return (\n        <a href={message.fileUrl} target=\"_blank\" rel=\"noreferrer\">\n          {message.text || message.fileName}\n        </a>\n      );\n    }\n    return <span>{message.text}</span>;\n  }\n}\n\nconst QuickReplies: MessageRenderer = (message, helpers) => {\n  return (\n    <div className=\"cs-quick-replies\" role=\"group\" aria-label=\"Suggested replies\">\n      {message.text && <div className=\"cs-chat-message-text\">{message.text}</div>}\n      <div className=\"cs-quick-replies-list\">\n        {(message.payload?.actions || []).map((action) => (\n          <button\n            key={`${message.id}_${action.value}`}\n            className=\"cs-quick-reply\"\n            type=\"button\"\n            onClick={() => helpers.onQuickReply?.(action.value)}\n          >\n            {action.label}\n          </button>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nconst CardRenderer: MessageRenderer = (message) => {\n  const payload = message.payload || {};\n  return (\n    <article className=\"cs-card\" aria-label={payload.title || message.text}>\n      {payload.imageUrl && (\n        <div className=\"cs-card-media\">\n          <img src={payload.imageUrl} alt={payload.title || \"Card image\"} />\n        </div>\n      )}\n      <div className=\"cs-card-content\">\n        <h4>{payload.title || message.text}</h4>\n        {payload.body && <p>{payload.body}</p>}\n        {payload.actions && (\n          <div className=\"cs-card-actions\">\n            {payload.actions.map((action) => (\n              <a key={action.value} href={action.url || \"#\"} className=\"cs-card-link\">\n                {action.label}\n              </a>\n            ))}\n          </div>\n        )}\n      </div>\n    </article>\n  );\n};\n\nconst ProductRenderer: MessageRenderer = (message) => {\n  const payload = message.payload || {};\n  return (\n    <article className=\"cs-card\" aria-label={payload.title || \"Product\"}>\n      {payload.imageUrl && (\n        <div className=\"cs-card-media\">\n          <img src={payload.imageUrl} alt={payload.title || \"Product image\"} />\n        </div>\n      )}\n      <div className=\"cs-card-content\">\n        <h4>{payload.title || message.text}</h4>\n        {payload.body && <p>{payload.body}</p>}\n        {payload.actions && payload.actions.length > 0 && (\n          <div className=\"cs-card-actions\">\n            {payload.actions.map((action) => (\n              <a key={action.value} href={action.url || \"#\"} className=\"cs-card-link\">\n                {action.label}\n              </a>\n            ))}\n          </div>\n        )}\n      </div>\n    </article>\n  );\n};\n\nconst SurveyRenderer: MessageRenderer = (message, helpers) => {\n  const payload = message.payload || {};\n  return (\n    <div className=\"cs-survey\" role=\"form\" aria-label={payload.title || \"Survey\"}>\n      <div className=\"cs-survey-header\">\n        <strong>{payload.title || message.text}</strong>\n        {payload.body && <p>{payload.body}</p>}\n      </div>\n      <div className=\"cs-survey-actions\" role=\"group\" aria-label=\"Survey responses\">\n        {(payload.actions || []).map((action) => (\n          <button\n            key={action.value}\n            type=\"button\"\n            className=\"cs-quick-reply\"\n            onClick={() => helpers.onQuickReply?.(action.value)}\n          >\n            {action.label}\n          </button>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport const defaultMessageRegistry = new MessageComponentRegistry();\ndefaultMessageRegistry.register(\"quick_replies\", QuickReplies);\ndefaultMessageRegistry.register(\"card\", CardRenderer);\ndefaultMessageRegistry.register(\"product\", ProductRenderer);\ndefaultMessageRegistry.register(\"survey\", SurveyRenderer);\ndefaultMessageRegistry.register(\"text\", (msg) => <span>{msg.text}</span>);\n","import { BaconPlugin, BeforeSendResult, SendErrorResult, cloneSafe } from \"./BaconPlugin\";\n\nfunction nowIso() {\n  return new Date().toISOString();\n}\n\nexport interface LoggingPluginOptions {\n  log?: (event: string, detail?: unknown) => void;\n}\n\nexport function createLoggingPlugin(options: LoggingPluginOptions = {}): BaconPlugin {\n  const logger = options.log ?? ((event, detail) => console.info(`[bacon:${event}]`, detail));\n  return {\n    name: \"logging\",\n    onInit: (ctx) => logger(\"init\", { ctx }),\n    onWidgetOpen: () => logger(\"ui_open\"),\n    onWidgetClose: () => logger(\"ui_close\"),\n    onConnectionEvent: (meta) => logger(\"connection\", meta),\n    onBeforeSend: (payload) => {\n      logger(\"before_send\", { payload });\n    },\n    onAfterSend: (_payload, response) => logger(\"after_send\", { response }),\n    onMessages: (messages) => {\n      logger(\"messages\", { count: messages.length });\n    },\n    onTelemetry: (event) => logger(\"transport_telemetry\", event),\n    onSendError: (error) => {\n      logger(\"send_error\", { error: error instanceof Error ? error.message : String(error) });\n    },\n  };\n}\n\nexport interface TracingPluginOptions {\n  traceIdFactory?: () => string;\n}\n\nexport function createTracingPlugin(options: TracingPluginOptions = {}): BaconPlugin {\n  const makeTraceId = options.traceIdFactory ?? (() => crypto.randomUUID?.() ?? `trace_${Date.now()}`);\n  return {\n    name: \"tracing\",\n    onBeforeSend: (payload, ctx): BeforeSendResult => {\n      const traceId = makeTraceId();\n      const enriched = cloneSafe(payload);\n      enriched.metadata = { ...(enriched.metadata ?? {}), traceId, sentAt: nowIso() };\n      return { payload: enriched };\n    },\n    onAfterSend: (_payload, _response, ctx) => {\n      console.debug(`[trace] completed send for ${ctx.sessionId}`);\n    },\n    onMessages: (messages): { messages: typeof messages } => {\n      return { messages: messages.map((m) => ({ ...m, metadata: { ...(m as any).metadata } })) };\n    },\n  };\n}\n\nexport interface AuthTokenRefresherOptions {\n  /** Acquire a new token when the plugin decides to refresh. */\n  fetchToken: () => Promise<string>;\n  /** Whether a given error warrants a retry. Defaults to 401 detection. */\n  shouldRefresh?: (error: unknown) => boolean;\n}\n\nexport function createAuthTokenRefresherPlugin(\n  options: AuthTokenRefresherOptions,\n): BaconPlugin {\n  const shouldRefresh =\n    options.shouldRefresh ?? ((error: unknown) => (error as Error)?.message?.includes(\"401\"));\n  let cachedToken: string | null = null;\n\n  const injectToken = async (payload: any): Promise<BeforeSendResult> => {\n    if (!cachedToken) {\n      cachedToken = await options.fetchToken();\n    }\n    const next = cloneSafe(payload);\n    next.metadata = { ...(next.metadata ?? {}), authToken: cachedToken };\n    return { payload: next };\n  };\n\n  return {\n    name: \"auth_token_refresher\",\n    onBeforeSend: (payload) => injectToken(payload),\n    onSendError: async (error, payload): Promise<SendErrorResult> => {\n      if (!shouldRefresh(error)) return {};\n      cachedToken = await options.fetchToken();\n      const next = cloneSafe(payload);\n      next.metadata = { ...(next.metadata ?? {}), authToken: cachedToken, refreshedAt: nowIso() };\n      return { retry: true, payload: next, waitMs: 50 };\n    },\n  };\n}\n","import { ConversationPage, ConversationServiceOptions, ConversationSummary } from \"./types\"\n\ninterface CacheEntry {\n  page: ConversationPage\n  fetchedAt: number\n}\n\n/**\n * Centralized, cache-aware data service that streams conversation pages with\n * cancellation and retry support. It is intentionally framework-agnostic so it\n * can be used inside React components, background sync workers, or Node\n * scripts. Extensive comments capture operational edge cases for future\n * maintainers.\n */\nexport class ConversationDataService {\n  private readonly baseUrl: string\n  private readonly pageSize?: number\n  private readonly maxRetries: number\n  private readonly retryBackoffMs: number\n  private readonly cache = new Map<string, CacheEntry>()\n  private readonly inflight = new Map<\n    string,\n    { controller: AbortController; promise: Promise<ConversationPage> }\n  >()\n\n  constructor(options: ConversationServiceOptions) {\n    this.baseUrl = options.baseUrl\n    this.pageSize = options.pageSize\n    this.maxRetries = options.maxRetries ?? 3\n    this.retryBackoffMs = options.retryBackoffMs ?? 300\n  }\n\n  /**\n   * Returns a cached page when available. We cache each cursor separately to\n   * avoid pagination gaps when multiple UI elements request different slices.\n   */\n  getCachedPage(cursor: string = \"start\"): ConversationPage | undefined {\n    return this.cache.get(cursor)?.page\n  }\n\n  /**\n   * Attempts to cancel any inflight request for the provided cursor. This is\n   * especially helpful when the UI unmounts or when rapid scrolling triggers\n   * superseded fetches.\n   */\n  cancel(cursor: string = \"start\"): void {\n    const inflight = this.inflight.get(cursor)\n    if (inflight) {\n      inflight.controller.abort()\n      this.inflight.delete(cursor)\n    }\n  }\n\n  /**\n   * Clears all cached pages. Useful when a user changes workspaces/tenants and\n   * stale data must be flushed without reloading the page.\n   */\n  reset(): void {\n    this.cache.clear()\n    this.inflight.forEach(({ controller }) => controller.abort())\n    this.inflight.clear()\n  }\n\n  /**\n   * Fetches a single page of conversations with retries and caching. Requests\n   * for the same cursor are deduplicated so concurrent callers share the same\n   * network response. Consumers receive a fresh object to avoid accidental\n   * mutation of cache entries.\n   */\n  async fetchPage(cursor: string = \"start\", signal?: AbortSignal): Promise<ConversationPage> {\n    const existing = this.cache.get(cursor)\n    if (existing) {\n      return { ...existing.page, conversations: [...existing.page.conversations] }\n    }\n\n    const inflight = this.inflight.get(cursor)\n    if (inflight) {\n      // Attach to the inflight promise; if the caller also provides a signal we\n      // honor cancellation locally even while the shared request may continue.\n      if (signal) {\n        signal.addEventListener(\"abort\", () => inflight.controller.abort(), { once: true })\n      }\n      return inflight.promise\n    }\n\n    const controller = new AbortController()\n    const mergedSignal = signal\n      ? this.mergeSignals(signal, controller.signal)\n      : controller.signal\n\n    const promise = this.fetchWithRetry(cursor, mergedSignal)\n      .then((page) => {\n        this.cache.set(cursor, { page, fetchedAt: Date.now() })\n        this.inflight.delete(cursor)\n        return { ...page, conversations: [...page.conversations] }\n      })\n      .catch((err) => {\n        this.inflight.delete(cursor)\n        throw err\n      })\n\n    this.inflight.set(cursor, { controller, promise })\n    return promise\n  }\n\n  /**\n   * Internal helper to compose multiple AbortSignals without requiring\n   * AbortSignal.any (which is still experimental in some browsers). We also add\n   * generous documentation so future refactors preserve cancellation behavior.\n   */\n  private mergeSignals(a: AbortSignal, b: AbortSignal): AbortSignal {\n    if (a.aborted) return a\n    if (b.aborted) return b\n\n    const controller = new AbortController()\n\n    // We intentionally ignore abort reasons here because only the cancellation\n    // event matters; this avoids cross-browser differences while still halting\n    // downstream fetches.\n    const abort = () => controller.abort()\n    a.addEventListener(\"abort\", abort, { once: true })\n    b.addEventListener(\"abort\", abort, { once: true })\n\n    return controller.signal\n  }\n\n  private async fetchWithRetry(cursor: string, signal: AbortSignal): Promise<ConversationPage> {\n    let attempt = 0\n    let lastError: unknown\n\n    while (attempt <= this.maxRetries) {\n      try {\n        const url = new URL(this.baseUrl, window.location.origin)\n        if (cursor !== \"start\") {\n          url.searchParams.set(\"cursor\", cursor)\n        }\n        if (this.pageSize) {\n          url.searchParams.set(\"limit\", String(this.pageSize))\n        }\n\n        const response = await fetch(url.toString(), { signal })\n        if (!response.ok) {\n          // Treat 5xx and 429 as retryable; 4xx should fail fast to avoid\n          // hammering the API with malformed requests.\n          if (response.status >= 500 || response.status === 429) {\n            throw new RetryableError(`Server returned ${response.status}`)\n          }\n          throw new Error(`Failed to load conversations (${response.status})`)\n        }\n\n        const payload: ConversationPage = await response.json()\n\n        // Normalize missing arrays so downstream code can assume a stable shape.\n        const conversations = payload.conversations ?? []\n        return { conversations, nextCursor: payload.nextCursor }\n      } catch (err) {\n        if (signal.aborted) {\n          throw new Error(\"Conversation request cancelled\")\n        }\n\n        lastError = err\n        const isRetryable =\n          err instanceof RetryableError ||\n          (err instanceof TypeError && attempt < this.maxRetries)\n\n        if (!isRetryable || attempt === this.maxRetries) {\n          throw err\n        }\n\n        const backoff = this.retryBackoffMs * 2 ** attempt\n        await this.delay(backoff, signal)\n        attempt += 1\n      }\n    }\n\n    throw lastError ?? new Error(\"Unknown conversation fetch failure\")\n  }\n\n  private delay(ms: number, signal: AbortSignal): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const timeout = window.setTimeout(() => {\n        signal.removeEventListener(\"abort\", onAbort)\n        resolve()\n      }, ms)\n\n      const onAbort = () => {\n        window.clearTimeout(timeout)\n        reject(new Error(\"Conversation request cancelled\"))\n      }\n\n      signal.addEventListener(\"abort\", onAbort, { once: true })\n    })\n  }\n}\n\nclass RetryableError extends Error {}\n\nexport function sortConversations(conversations: ConversationSummary[]): ConversationSummary[] {\n  return [...conversations].sort((a, b) => (a.lastMessageAt > b.lastMessageAt ? -1 : 1))\n}\n","import React, { useCallback, useMemo, useRef } from \"react\"\nimport { ConversationDataService, sortConversations } from \"./ConversationDataService\"\nimport { useConversationFeed } from \"./useConversationFeed\"\nimport { ConversationSummary } from \"./types\"\nimport \"./ConversationSidebar.css\"\n\nexport interface ConversationSidebarProps {\n  service: ConversationDataService\n  selectedConversationId?: string\n  onSelectConversation?: (conversationId: string) => void\n  title?: string\n}\n\nfunction formatTimestamp(timestamp: string): string {\n  const date = new Date(timestamp)\n  return date.toLocaleString(undefined, {\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    month: \"short\",\n    day: \"numeric\",\n  })\n}\n\nfunction renderPreview(preview?: string): string {\n  if (!preview) return \"No recent messages yet\"\n  return preview.length > 80 ? `${preview.slice(0, 77)}...` : preview\n}\n\n/**\n * ConversationSidebar presents an infinitely-scrollable list of conversations\n * with strong keyboard/a11y support and low-friction loading/error states. It\n * keeps the visual layer thin by deferring caching/retry/cancellation to the\n * ConversationDataService + useConversationFeed hook.\n */\nexport const ConversationSidebar: React.FC<ConversationSidebarProps> = ({\n  service,\n  onSelectConversation,\n  selectedConversationId,\n  title = \"Inbox\",\n}) => {\n  const listRef = useRef<HTMLUListElement | null>(null)\n  const { conversations, loading, error, hasMore, loadMore, retry } = useConversationFeed(\n    service\n  )\n\n  const sorted = useMemo(() => sortConversations(conversations), [conversations])\n\n  const handleScroll = useCallback(() => {\n    const node = listRef.current\n    if (!node || !hasMore || loading) return\n\n    const distanceToBottom = node.scrollHeight - node.scrollTop - node.clientHeight\n    if (distanceToBottom < 96) {\n      loadMore()\n    }\n  }, [hasMore, loadMore, loading])\n\n  const handleKeyDown = useCallback(\n    (event: React.KeyboardEvent<HTMLButtonElement>, index: number) => {\n      if (!listRef.current) return\n\n      const elements = listRef.current.querySelectorAll<HTMLButtonElement>(\"button[role='option']\")\n      const targetIndex = event.key === \"ArrowDown\" ? index + 1 : event.key === \"ArrowUp\" ? index - 1 : index\n      if (targetIndex < 0 || targetIndex >= elements.length) return\n      elements[targetIndex].focus()\n      event.preventDefault()\n    },\n    []\n  )\n\n  const renderItem = (conversation: ConversationSummary, index: number) => {\n    const isSelected = conversation.id === selectedConversationId\n    return (\n      <li key={conversation.id} className=\"cs-sidebar-row\">\n        <button\n          type=\"button\"\n          role=\"option\"\n          aria-selected={isSelected}\n          className={`cs-sidebar-item ${isSelected ? \"cs-sidebar-item--active\" : \"\"}`}\n          onClick={() => onSelectConversation?.(conversation.id)}\n          onKeyDown={(event) => {\n            if (event.key === \"ArrowDown\" || event.key === \"ArrowUp\") {\n              handleKeyDown(event, index)\n            }\n          }}\n        >\n          <div className=\"cs-sidebar-item__header\">\n            <span className=\"cs-sidebar-item__title\">{conversation.title}</span>\n            <span className=\"cs-sidebar-item__timestamp\" aria-label=\"Last updated\">\n              {formatTimestamp(conversation.lastMessageAt)}\n            </span>\n          </div>\n          <div className=\"cs-sidebar-item__body\">\n            <span className=\"cs-sidebar-item__preview\">{renderPreview(conversation.lastMessagePreview)}</span>\n            {conversation.unread ? <span className=\"cs-sidebar-item__unread\" aria-label=\"Unread\" /> : null}\n          </div>\n          {conversation.participantLabel ? (\n            <span className=\"cs-sidebar-item__participant\">{conversation.participantLabel}</span>\n          ) : null}\n        </button>\n      </li>\n    )\n  }\n\n  return (\n    <aside className=\"cs-sidebar\" aria-label=\"Conversation list\">\n      <div className=\"cs-sidebar__header\">\n        <h2 className=\"cs-sidebar__title\">{title}</h2>\n        {loading ? <span className=\"cs-sidebar__spinner\" aria-live=\"polite\">Loadingâ€¦</span> : null}\n      </div>\n      {error ? (\n        <div className=\"cs-sidebar__error\" role=\"alert\">\n          <p>We could not load conversations. Please retry.</p>\n          <button type=\"button\" onClick={retry} className=\"cs-sidebar__retry\">\n            Retry\n          </button>\n        </div>\n      ) : null}\n      <ul\n        ref={listRef}\n        className=\"cs-sidebar__list\"\n        role=\"listbox\"\n        aria-label=\"Conversations\"\n        tabIndex={0}\n        onScroll={handleScroll}\n      >\n        {sorted.map((conversation, index) => renderItem(conversation, index))}\n        {!loading && sorted.length === 0 && !error ? (\n          <li className=\"cs-sidebar__empty\">No conversations yet.</li>\n        ) : null}\n        {loading ? <li className=\"cs-sidebar__loading\">Loading conversationsâ€¦</li> : null}\n      </ul>\n      {hasMore && !loading ? (\n        <button type=\"button\" className=\"cs-sidebar__load-more\" onClick={loadMore}>\n          Load more\n        </button>\n      ) : null}\n    </aside>\n  )\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\nimport { ConversationDataService } from \"./ConversationDataService\"\nimport { ConversationPage, ConversationSummary } from \"./types\"\n\ninterface ConversationFeedState {\n  pages: ConversationPage[]\n  loading: boolean\n  error?: Error\n  hasMore: boolean\n}\n\n/**\n * React hook that wraps the ConversationDataService with view-friendly state\n * (loading/error flags) plus incremental pagination helpers. The hook is\n * intentionally defensive: it cancels inflight requests on unmount and uses\n * stable callbacks so scroll listeners can be attached without churn.\n */\nexport function useConversationFeed(\n  service: ConversationDataService,\n  initialCursor: string = \"start\"\n) {\n  const [state, setState] = useState<ConversationFeedState>({\n    pages: [],\n    loading: false,\n    hasMore: true,\n  })\n\n  const cursorRef = useRef<string | undefined>(initialCursor)\n  const abortRef = useRef<AbortController | null>(null)\n\n  const conversations = useMemo<ConversationSummary[]>(\n    () => state.pages.flatMap((page) => page.conversations),\n    [state.pages]\n  )\n\n  const loadPage = useCallback(\n    async (cursor?: string) => {\n      // Prevent duplicate loads while a fetch is running.\n      if (state.loading) return\n\n      const controller = new AbortController()\n      abortRef.current = controller\n\n      setState((prev) => ({ ...prev, loading: true, error: undefined }))\n\n      try {\n        const page = await service.fetchPage(cursor, controller.signal)\n        setState((prev) => {\n          const pages = cursor === initialCursor ? [page] : [...prev.pages, page]\n          return {\n            pages,\n            loading: false,\n            error: undefined,\n            hasMore: Boolean(page.nextCursor),\n          }\n        })\n        cursorRef.current = page.nextCursor\n      } catch (err) {\n        if ((err as Error).message.includes(\"cancelled\")) {\n          // Cancellation is an expected control-flow path (e.g., unmount). Keep\n          // the previous state intact to avoid flashing errors to the user.\n          return\n        }\n        setState((prev) => ({ ...prev, loading: false, error: err as Error }))\n      }\n    },\n    [initialCursor, service, state.loading]\n  )\n\n  useEffect(() => {\n    loadPage(initialCursor)\n\n    return () => {\n      abortRef.current?.abort()\n      service.cancel(cursorRef.current)\n    }\n  }, [initialCursor, loadPage, service])\n\n  const loadMore = useCallback(() => {\n    if (!state.hasMore || state.loading) return\n    loadPage(cursorRef.current)\n  }, [loadPage, state.hasMore, state.loading])\n\n  const retry = useCallback(() => {\n    loadPage(cursorRef.current ?? initialCursor)\n  }, [initialCursor, loadPage])\n\n  return {\n    conversations,\n    pages: state.pages,\n    loading: state.loading,\n    error: state.error,\n    hasMore: state.hasMore,\n    loadMore,\n    retry,\n  }\n}\n"],"mappings":";AAQA,SAAgB,WAAW,UAAU,QAAmB,WAAAA,gBAAe;;;ACkFhE,SAAS,eACd,SACA,QACA,OACQ;AACR,QAAM,SAAS,KAAK,IAAI,OAAO,SAAS,KAAK,IAAI,GAAG,OAAO,CAAC;AAC5D,QAAM,SAAS,KAAK,OAAO,IAAI,OAAO;AACtC,SAAO,KAAK,MAAM,SAAS,OAAO,MAAM;AAC1C;;;ACvEO,IAAM,mBAAN,MAA4C;AAAA,EAQjD,YAAoB,SAAkC;AAAlC;AAPpB,SAAgB,OAAO;AACvB,SAAO,QAAwB;AAC/B,SAAQ,WAAmC,CAAC;AAC5C,SAAQ,QAA8C;AACtD,SAAQ,UAAU;AAClB,SAAQ,UAAU;AAAA,EAEqC;AAAA,EAEvD,iBAAiB,UAAwC;AACvD,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,MAAM,UAAyB;AAzCjC;AA0CI,QAAI,KAAK,UAAU,UAAU,KAAK,UAAU,aAAc;AAC1D,SAAK,UAAU;AACf,SAAK,QAAQ;AACb,qBAAK,UAAS,gBAAd,4BAA4B;AAAA,MAC1B,MAAM;AAAA,MACN,IAAI,KAAK,IAAI;AAAA,MACb,QAAQ,EAAE,QAAQ,KAAK,QAAQ,OAAO;AAAA,IACxC;AACA,SAAK,aAAa,CAAC;AAAA,EACrB;AAAA,EAEA,MAAM,WAAW,QAAgC;AArDnD;AAsDI,SAAK,UAAU;AACf,SAAK,QAAQ;AACb,QAAI,KAAK,OAAO;AACd,mBAAa,KAAK,KAAK;AACvB,WAAK,QAAQ;AAAA,IACf;AACA,qBAAK,UAAS,YAAd,4BAAwB;AAAA,EAC1B;AAAA,EAEA,MAAM,KAAK,SAA0D;AA/DvE;AAgEI,UAAM,UAAkC;AAAA,MACtC,gBAAgB;AAAA,MAChB,GAAG,KAAK,QAAQ;AAAA,IAClB;AACA,QAAI,KAAK,QAAQ,WAAW;AAC1B,cAAQ,eAAe,IAAI,UAAU,KAAK,QAAQ,SAAS;AAAA,IAC7D;AACA,UAAM,WAAW,MAAM,MAAM,KAAK,QAAQ,QAAQ;AAAA,MAChD,QAAQ;AAAA,MACR;AAAA,MACA,MAAM,KAAK,UAAU,OAAO;AAAA,IAC9B,CAAC;AACD,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,QAAQ,IAAI;AAAA,QAChB,kCAAkC,SAAS,MAAM,KAAK,SAAS,UAAU;AAAA,MAC3E;AACA,uBAAK,UAAS,YAAd,4BAAwB;AACxB,YAAM;AAAA,IACR;AACA,UAAM,OAAQ,MAAM,SAAS,KAAK;AAClC,qBAAK,UAAS,gBAAd,4BAA4B,EAAE,MAAM,gBAAgB,IAAI,KAAK,IAAI,EAAE;AACnE,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,SACJ,MACA,UACkC;AA3FtC;AA4FI,UAAM,OAAO,IAAI,SAAS;AAC1B,SAAK,OAAO,aAAa,KAAK,QAAQ,SAAS;AAC/C,QAAI,UAAU;AACZ,iBAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,QAAQ,GAAG;AAC7C,aAAK,OAAO,GAAG,CAAC;AAAA,MAClB;AAAA,IACF;AACA,SAAK,OAAO,QAAQ,MAAM,KAAK,IAAI;AACnC,UAAM,YACJ,KAAK,QAAQ,aAAa,KAAK,QAAQ,OAAO,QAAQ,WAAW,SAAS;AAC5E,UAAM,WAAW,MAAM,MAAM,WAAW,EAAE,QAAQ,QAAQ,MAAM,KAAK,CAAC;AACtE,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,QAAQ,IAAI,MAAM,kBAAkB,SAAS,MAAM,EAAE;AAC3D,uBAAK,UAAS,YAAd,4BAAwB;AACxB,YAAM;AAAA,IACR;AACA,QAAI;AACF,YAAM,SAAS,MAAM,SAAS,KAAK;AACnC,YAAM,OAAM,4CAAQ,UAAR,mBAAgB,OAAhB,mBAAoB;AAChC,UAAI,KAAK;AACP,eAAO;AAAA,UACL,IAAI,QAAQ,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AAAA,UAC7D,QAAQ;AAAA,UACR,MAAM,kBAAkB,KAAK,IAAI;AAAA,UACjC,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UAClC,SAAS;AAAA,UACT,UAAU,KAAK;AAAA,QACjB;AAAA,MACF;AAAA,IACF,SAAS,GAAG;AACV,uBAAK,UAAS,gBAAd,4BAA4B;AAAA,QAC1B,MAAM;AAAA,QACN,IAAI,KAAK,IAAI;AAAA,QACb,QAAQ,EAAE,OAAQ,EAAY,QAAQ;AAAA,MACxC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,aAAa,OAAe;AAClC,QAAI,KAAK,QAAS;AAClB,SAAK,QAAQ,WAAW,MAAM;AAC5B,WAAK,KAAK,KAAK;AAAA,IACjB,GAAG,KAAK;AAAA,EACV;AAAA,EAEA,MAAc,OAAO;AA1IvB;AA2II,QAAI,KAAK,QAAS;AAClB,UAAM,YAAW,UAAK,QAAQ,mBAAb,YAA+B;AAChD,UAAM,QAAQ,IAAI,gBAAgB;AAClC,UAAM,WAAU,UAAK,QAAQ,sBAAb,YAAkC;AAClD,UAAM,QAAQ,WAAW,MAAM,MAAM,MAAM,GAAG,OAAO;AACrD,UAAM,cAAc,KAAK,QAAQ,OAAO,SAAS,OAAO,IACpD,KAAK,QAAQ,SACb,KAAK,QAAQ,OAAO,QAAQ,OAAO,EAAE,IAAI;AAC7C,QAAI;AACF,YAAM,MAAM,MAAM;AAAA,QAChB,GAAG,WAAW,cAAc,mBAAmB,KAAK,QAAQ,SAAS,CAAC;AAAA,QACtE;AAAA,UACE,QAAQ,MAAM;AAAA,UACd,SAAS,KAAK,aAAa;AAAA,QAC7B;AAAA,MACF;AACA,mBAAa,KAAK;AAClB,UAAI,CAAC,IAAI,GAAI,OAAM,IAAI,MAAM,mBAAmB,IAAI,MAAM,EAAE;AAC5D,YAAM,OAAQ,MAAM,IAAI,KAAK;AAC7B,WAAK,QAAQ;AACb,WAAK,UAAU;AACf,uBAAK,UAAS,WAAd;AACA,uBAAK,UAAS,cAAd,4BAA0B,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC;AACxD,uBAAK,UAAS,gBAAd,4BAA4B,EAAE,MAAM,gBAAgB,IAAI,KAAK,IAAI,EAAE;AACnE,WAAK,aAAa,QAAQ;AAAA,IAC5B,SAAS,KAAK;AACZ,mBAAa,KAAK;AAClB,WAAK,QAAQ;AACb,YAAM,SAAS,eAAe,QAAQ,IAAI,UAAU,OAAO,GAAG;AAC9D,uBAAK,UAAS,YAAd,4BAAwB;AACxB,uBAAK,UAAS,gBAAd,4BAA4B;AAAA,QAC1B,MAAM;AAAA,QACN,IAAI,KAAK,IAAI;AAAA,QACb,QAAQ,EAAE,SAAS,KAAK,UAAU,GAAG,OAAO,OAAO;AAAA,MACrD;AACA,YAAM,QAAQ;AAAA,QACZ,KAAK;AAAA,SACL,UAAK,QAAQ,kBAAb,YAA8B;AAAA,SAC9B,UAAK,QAAQ,iBAAb,YAA6B;AAAA,MAC/B;AACA,WAAK,aAAa,KAAK;AAAA,IACzB;AAAA,EACF;AAAA,EAEQ,eAAuC;AAC7C,UAAM,UAAkC,EAAE,GAAI,KAAK,QAAQ,WAAW,CAAC,EAAG;AAC1E,QAAI,KAAK,QAAQ,WAAW;AAC1B,cAAQ,eAAe,IAAI,UAAU,KAAK,QAAQ,SAAS;AAAA,IAC7D;AACA,WAAO;AAAA,EACT;AACF;;;ACpJO,IAAM,qBAAN,MAA8C;AAAA,EAUnD,YAAoB,SAAoC;AAApC;AATpB,SAAgB,OAAO;AACvB,SAAO,QAAwB;AAC/B,SAAQ,WAAmC,CAAC;AAC5C,SAAQ,SAAgD;AACxD,SAAQ,mBAAmB;AAC3B,SAAQ,iBAAwD;AAChE,SAAQ,eAAe;AACvB,SAAQ,eAAyB,CAAC;AAAA,EAEuB;AAAA,EAEzD,iBAAiB,UAAwC;AACvD,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,MAAM,UAAyB;AA1DjC;AA2DI,QAAI,KAAK,UAAU,UAAU,KAAK,UAAU,aAAc;AAC1D,SAAK,eAAe;AACpB,SAAK,QAAQ;AACb,UAAM,MAAM,KAAK,WAAW;AAC5B,UAAM,SAAS,KAAK,YAAY;AAChC,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,qBAAK,UAAS,gBAAd,4BAA4B,EAAE,MAAM,cAAc,IAAI,KAAK,IAAI,GAAG,QAAQ,EAAE,IAAI,EAAE;AAClF,SAAK,SAAS,IAAI,OAAO,GAAG;AAC5B,SAAK,iBAAiB,KAAK,MAAmB;AAAA,EAChD;AAAA,EAEA,MAAM,WAAW,QAAgC;AAzEnD;AA0EI,SAAK,eAAe;AACpB,SAAK,QAAQ;AACb,QAAI,KAAK,eAAgB,eAAc,KAAK,cAAc;AAC1D,QAAI,CAAC,KAAK,OAAQ;AAClB,QAAI,WAAW,KAAK,QAAQ;AAC1B,MAAC,KAAK,OAAe,MAAM;AAAA,IAC7B;AACA,QAAI,gBAAgB,KAAK,QAAQ;AAC/B,MAAC,KAAK,OAA8B,WAAW;AAAA,IACjD;AACA,qBAAK,UAAS,YAAd,4BAAwB;AAAA,EAC1B;AAAA,EAEA,MAAM,KAAK,SAA0D;AACnE,UAAM,WAAW,KAAK,UAAU;AAAA,MAC9B,MAAM;AAAA,MACN,WAAW,KAAK,QAAQ;AAAA,MACxB,gBAAgB,KAAK,QAAQ;AAAA,MAC7B;AAAA,IACF,CAAC;AACD,QAAI,KAAK,UAAW,KAAK,OAAqB,eAAe,UAAU,MAAM;AAC3E,MAAC,KAAK,OAAqB,KAAK,QAAQ;AACxC;AAAA,IACF;AACA,QAAI,KAAK,UAAU,UAAU,KAAK,QAAQ;AACxC,MAAC,KAAK,OAA8B,KAAK,WAAW,QAAQ;AAC5D;AAAA,IACF;AAEA,SAAK,aAAa,KAAK,QAAQ;AAAA,EACjC;AAAA,EAEA,MAAM,SACJ,MACA,UACkC;AAClC,UAAM,WAAW;AAAA,MACf,MAAM;AAAA,MACN,WAAW,KAAK,QAAQ;AAAA,MACxB;AAAA,MACA,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,IACb;AACA,UAAM,UAAU,KAAK,UAAU,QAAQ;AACvC,QAAI,KAAK,UAAW,KAAK,OAAqB,eAAe,UAAU,MAAM;AAC3E,MAAC,KAAK,OAAqB,KAAK,OAAO;AACvC,MAAC,KAAK,OAAqB,KAAK,IAAI;AAAA,IACtC,WAAW,KAAK,UAAU,UAAU,KAAK,QAAQ;AAC/C,MAAC,KAAK,OAA8B,KAAK,QAAQ,EAAE,GAAG,UAAU,KAAK,CAAC;AAAA,IACxE,OAAO;AACL,WAAK,aAAa,KAAK,OAAO;AAAA,IAChC;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,aAAa;AACnB,QAAI,KAAK,QAAQ,aAAc,QAAO,KAAK,QAAQ;AAEnD,UAAM,SAAS,IAAI,IAAI,KAAK,QAAQ,QAAQ,OAAO,WAAW,cAAc,OAAO,SAAS,OAAO,MAAS;AAC5G,WAAO,WAAW,OAAO,aAAa,WAAW,SAAS;AAC1D,WAAO,WAAW,OAAO,SAAS,QAAQ,OAAO,EAAE,IAAI;AACvD,WAAO,OAAO,SAAS;AAAA,EACzB;AAAA,EAEQ,cAAuC;AAC7C,QAAI,KAAK,QAAQ,iBAAiB;AAEhC,YAAM,UAAU,KAAK,QAAQ;AAG7B,YAAM,OAAyB,MAAM;AAAA,QAGnC,YAAY,KAAa;AAFzB,eAAQ,SAAS,QAAS,EAAE;AAC5B,eAAO,aAAa,UAAU;AAE5B,eAAK,SAAS,QAAS,KAAK,EAAE,YAAY,CAAC,WAAW,GAAG,iBAAiB,KAAK,CAAC;AAAA,QAClF;AAAA,QACA,QAAQ;AACN,eAAK,OAAO,WAAW;AAAA,QACzB;AAAA,QACA,KAAK,SAAwB;AAC3B,eAAK,OAAO,KAAK,WAAW,OAAO;AAAA,QACrC;AAAA,QACA,iBAAiB,OAAe,IAAuB;AACrD,eAAK,OAAO,GAAG,OAAO,EAAE;AAAA,QAC1B;AAAA,QACA,oBAAoB,OAAe,IAAuB;AACxD,eAAK,OAAO,IAAI,OAAO,EAAE;AAAA,QAC3B;AAAA;AAAA,MAEF;AACA,aAAO;AAAA,IACT;AACA,QAAI,KAAK,QAAQ,cAAe,QAAO,KAAK,QAAQ;AACpD,QAAI,OAAO,cAAc,YAAa,QAAO;AAC7C,WAAO;AAAA,EACT;AAAA,EAEQ,iBAAiB,QAAmB;AAC1C,WAAO,iBAAiB,QAAQ,MAAM;AA5K1C;AA6KM,WAAK,QAAQ;AACb,WAAK,mBAAmB;AACxB,uBAAK,UAAS,WAAd;AACA,WAAK,WAAW;AAChB,WAAK,eAAe,MAAM;AAAA,IAC5B,CAAC;AACD,WAAO,iBAAiB,WAAW,CAAC,UAAU;AAnLlD;AAoLM,UAAI;AACF,cAAM,SAAS,KAAK,MAAM,MAAM,IAAc;AAC9C,YAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,2BAAK,UAAS,cAAd,4BAA0B;AAAA,QAC5B,WAAW,iCAAQ,OAAO;AACxB,2BAAK,UAAS,cAAd,4BAA0B;AAAA,YACxB;AAAA,cACE,IAAI,OAAO,KAAK,IAAI,CAAC;AAAA,cACrB,QAAQ;AAAA,cACR,MAAM,OAAO;AAAA,cACb,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,YACpC;AAAA,UACF;AAAA,QACF,OAAO;AACL,2BAAK,UAAS,cAAd,4BAA0B;AAAA,QAC5B;AAAA,MACF,SAAS,KAAK;AACZ,yBAAK,UAAS,YAAd,4BAAwB;AAAA,MAC1B;AAAA,IACF,CAAC;AACD,WAAO,iBAAiB,SAAS,MAAM;AAxM3C;AAyMM,WAAK,QAAQ;AACb,uBAAK,UAAS,YAAd;AACA,WAAK,cAAc;AACnB,UAAI,CAAC,KAAK,cAAc;AACtB,aAAK,kBAAkB;AAAA,MACzB;AAAA,IACF,CAAC;AACD,WAAO,iBAAiB,SAAS,CAAC,UAAU;AAhNhD;AAiNM,WAAK,QAAQ;AACb,uBAAK,UAAS,YAAd;AAAA;AAAA,QACE,iBAAiB,aACb,IAAI,MAAM,MAAM,OAAO,IACvB,IAAI,MAAM,iBAAiB;AAAA;AAEjC,WAAK,kBAAkB;AAAA,IACzB,CAAC;AAAA,EACH;AAAA,EAEQ,eAAe,QAAmB;AA3N5C;AA4NI,UAAM,YAAW,UAAK,QAAQ,gBAAb,YAA4B;AAC7C,QAAI,YAAY,EAAG;AACnB,SAAK,cAAc;AACnB,SAAK,iBAAiB,YAAY,MAAM;AACtC,UAAI,OAAO,eAAe,UAAU,MAAM;AACxC,eAAO,KAAK,KAAK,UAAU,EAAE,MAAM,QAAQ,IAAI,KAAK,IAAI,EAAE,CAAC,CAAC;AAAA,MAC9D;AAAA,IACF,GAAG,QAAQ;AAAA,EACb;AAAA,EAEQ,gBAAgB;AACtB,QAAI,KAAK,gBAAgB;AACvB,oBAAc,KAAK,cAAc;AACjC,WAAK,iBAAiB;AAAA,IACxB;AAAA,EACF;AAAA,EAEQ,oBAAoB;AA7O9B;AA8OI,QAAI,KAAK,aAAc;AACvB,UAAM,QAAQ;AAAA,MACZ,KAAK;AAAA,OACL,UAAK,QAAQ,kBAAb,YAA8B;AAAA,OAC9B,UAAK,QAAQ,iBAAb,YAA6B;AAAA,IAC/B;AACA,qBAAK,UAAS,gBAAd,4BAA4B;AAAA,MAC1B,MAAM;AAAA,MACN,IAAI,KAAK,IAAI;AAAA,MACb,QAAQ,EAAE,SAAS,KAAK,kBAAkB,MAAM;AAAA,IAClD;AACA,eAAW,MAAM;AACf,UAAI,CAAC,KAAK,cAAc;AACtB,aAAK,KAAK,QAAQ;AAAA,MACpB;AAAA,IACF,GAAG,KAAK;AAAA,EACV;AAAA,EAEQ,aAAa;AACnB,QAAI,CAAC,KAAK,OAAQ;AAClB,UAAM,KAAK,KAAK;AAChB,WAAO,KAAK,aAAa,UAAU,GAAG,eAAe,UAAU,MAAM;AACnE,YAAM,OAAO,KAAK,aAAa,MAAM;AACrC,UAAI,KAAM,IAAG,KAAK,IAAI;AAAA,IACxB;AAAA,EACF;AACF;;;ACrMO,SAAS,UAAa,OAAa;AACxC,MAAI,OAAO,oBAAoB,WAAY,QAAO,gBAAgB,KAAK;AACvE,SAAO,KAAK,MAAM,KAAK,UAAU,KAAK,CAAC;AACzC;AAEA,IAAM,cAAc;AAEb,IAAM,iBAAN,cAA6B,MAAM;AAAA,EACxC,cAAc;AACZ,UAAM,wBAAwB;AAAA,EAChC;AACF;AAOO,IAAM,eAAN,MAAmB;AAAA,EACxB,YAAoB,SAAgC,KAA2B;AAA3D;AAAgC;AAAA,EAA4B;AAAA,EAEhF,cAAc,SAAwC;AACpD,SAAK,MAAM,EAAE,GAAG,KAAK,KAAK,GAAG,QAAQ;AAAA,EACvC;AAAA,EAEA,MAAM,OAAO;AACX,UAAM,KAAK,IAAI,QAAQ;AAAA,EACzB;AAAA,EAEA,MAAM,cAAc;AAClB,UAAM,KAAK,IAAI,eAAe;AAAA,EAChC;AAAA,EAEA,MAAM,gBAAgB;AACpB,UAAM,KAAK,IAAI,iBAAiB;AAAA,EAClC;AAAA,EAEA,MAAM,WAAW,QAAiB;AAChC,UAAM,KAAK,IAAI,SAAS,iBAAiB,eAAe;AAAA,EAC1D;AAAA,EAEA,MAAM,iBAAiB,MAA2B;AAChD,UAAM,KAAK,IAAI,qBAAqB,IAAI;AAAA,EAC1C;AAAA,EAEA,MAAM,gBAAgB,OAAgC;AACpD,UAAM,KAAK,IAAI,eAAe,UAAU,KAAK,CAAC;AAAA,EAChD;AAAA,EAEA,MAAM,gBAAgB,UAAiD;AACrE,QAAI,UAAU,UAAU,QAAQ;AAChC,eAAW,UAAU,KAAK,SAAS;AACjC,UAAI,CAAC,OAAO,WAAY;AACxB,UAAI;AACF,cAAM,OAAO,MAAM,OAAO,WAAW,UAAU,OAAO,GAAG,KAAK,GAAG;AACjE,YAAI,6BAAM,SAAU,WAAU,UAAU,KAAK,QAAQ;AAAA,MACvD,SAAS,KAAK;AACZ,gBAAQ,KAAK,WAAW,OAAO,IAAI,uBAAuB,GAAG;AAAA,MAC/D;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KACJ,SACA,YACiC;AACjC,QAAI,iBAAiB,UAAU,OAAO;AACtC,QAAI,UAAU;AAEd,UAAM,kBAAkB,YAAY;AAClC,UAAI,UAAU;AACd,iBAAW,UAAU,KAAK,SAAS;AACjC,YAAI,CAAC,OAAO,aAAc;AAC1B,YAAI;AACF,gBAAM,SAAS,MAAM,OAAO,aAAa,UAAU,OAAO,GAAG,KAAK,GAAG;AACrE,cAAI,iCAAQ,MAAO,OAAM,IAAI,eAAe;AAC5C,cAAI,iCAAQ,QAAS,WAAU,UAAU,OAAO,OAAO;AACvD,eAAI,iCAAQ,cAAa,OAAW,QAAO,EAAE,cAAc,OAAO,SAAS;AAAA,QAC7E,SAAS,KAAK;AACZ,cAAI,eAAe,eAAgB,OAAM;AACzC,kBAAQ,KAAK,WAAW,OAAO,IAAI,yBAAyB,GAAG;AAAA,QACjE;AAAA,MACF;AACA,uBAAiB;AACjB,aAAO,EAAE,cAAc,OAAgD;AAAA,IACzE;AAEA,WAAO,WAAW,aAAa;AAC7B,UAAI;AACJ,UAAI;AACF,iBAAS,MAAM,gBAAgB;AAAA,MACjC,SAAS,KAAK;AACZ,YAAI,eAAe,gBAAgB;AACjC,gBAAM,KAAK,IAAI,eAAe,gBAAgB,MAAS;AACvD;AAAA,QACF;AACA,cAAM;AAAA,MACR;AACA,UAAI,OAAO,iBAAiB,QAAW;AACrC,cAAM,KAAK,IAAI,eAAe,gBAAgB,OAAO,YAAY;AACjE,eAAO,OAAO;AAAA,MAChB;AAEA,UAAI;AACF,cAAM,WAAW,MAAM,WAAW,cAAc;AAChD,cAAM,KAAK,IAAI,eAAe,gBAAgB,QAAQ;AACtD,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,YAAI,eAAe,eAAgB,OAAM;AACzC,cAAM,iBAAiB,MAAM,KAAK,gBAAgB,KAAK,cAAc;AACrE,YAAI,eAAe,SAAS,UAAU,aAAa;AACjD,qBAAW;AACX,cAAI,eAAe,QAAS,kBAAiB,UAAU,eAAe,OAAO;AAC7E,cAAI,eAAe,UAAU,eAAe,SAAS,GAAG;AACtD,kBAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,eAAe,MAAM,CAAC;AAAA,UAC3E;AACA;AAAA,QACF;AACA,cAAM;AAAA,MACR;AAAA,IACF;AACA,UAAM,IAAI,MAAM,sBAAsB;AAAA,EACxC;AAAA,EAEA,MAAc,gBAAgB,OAAgB,SAAmD;AAC/F,QAAI,YAA6B,CAAC;AAClC,eAAW,UAAU,KAAK,SAAS;AACjC,UAAI,CAAC,OAAO,YAAa;AACzB,UAAI;AACF,cAAM,OAAO,MAAM,OAAO,YAAY,OAAO,UAAU,OAAO,GAAG,KAAK,GAAG;AACzE,YAAI,6BAAM,MAAO,aAAY,EAAE,GAAG,WAAW,GAAG,KAAK;AAAA,MACvD,SAAS,KAAK;AACZ,gBAAQ,KAAK,WAAW,OAAO,IAAI,wBAAwB,GAAG;AAAA,MAChE;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,IACZ,SACG,MACY;AACf,eAAW,UAAU,KAAK,SAAS;AACjC,YAAM,KAAK,OAAO,IAAI;AACtB,UAAI,CAAC,GAAI;AACT,UAAI;AACF,cAAM,GAAG,MAAM,QAAQ,CAAC,GAAG,MAAM,KAAK,GAAG,CAAC;AAAA,MAC5C,SAAS,KAAK;AACZ,gBAAQ,KAAK,WAAW,OAAO,IAAI,KAAK,OAAO,IAAI,CAAC,WAAW,GAAG;AAAA,MACpE;AAAA,IACF;AAAA,EACF;AACF;;;ACjOA,SAAgB,eAAe,YAAY,eAAe;AAsBjD;AAnBT,IAAM,sBAAsB,cAAmC,IAAI;AAS5D,IAAM,iBAAgD,CAAC;AAAA,EAC5D,UAAU,CAAC;AAAA,EACX;AAAA,EACA,QAAQ;AAAA,EACR;AACF,MAAM;AACJ,QAAM,WAAW;AAAA,IACf,MAAM,kCAAc,IAAI,aAAa,SAAS,OAAO;AAAA,IACrD,CAAC,YAAY,SAAS,OAAO;AAAA,EAC/B;AACA,SAAO,oBAAC,oBAAoB,UAApB,EAA6B,OAAO,UAAW,UAAS;AAClE;AAEO,SAAS,kBAAuC;AACrD,SAAO,WAAW,mBAAmB;AACvC;;;ACaQ,gBAAAC,MAWJ,YAXI;AAhBD,IAAM,2BAAN,MAA+B;AAAA,EAA/B;AACL,SAAQ,YAAY,oBAAI,IAA6B;AAAA;AAAA,EAErD,SAAS,MAAc,UAA2B;AAChD,SAAK,UAAU,IAAI,MAAM,QAAQ;AAAA,EACnC;AAAA,EAEA,OAAO,SAAsB,UAAsD,CAAC,GAAG;AACrF,UAAM,WAAW,QAAQ,OAAO,KAAK,UAAU,IAAI,QAAQ,IAAI,IAAI;AACnE,QAAI,SAAU,QAAO,SAAS,SAAS,OAAO;AAC9C,WAAO,KAAK,eAAe,OAAO;AAAA,EACpC;AAAA,EAEQ,eAAe,SAAsB;AAC3C,QAAI,QAAQ,SAAS;AACnB,aACE,gBAAAA,KAAC,OAAE,MAAM,QAAQ,SAAS,QAAO,UAAS,KAAI,cAC3C,kBAAQ,QAAQ,QAAQ,UAC3B;AAAA,IAEJ;AACA,WAAO,gBAAAA,KAAC,UAAM,kBAAQ,MAAK;AAAA,EAC7B;AACF;AAEA,IAAM,eAAgC,CAAC,SAAS,YAAY;AAjD5D;AAkDE,SACE,qBAAC,SAAI,WAAU,oBAAmB,MAAK,SAAQ,cAAW,qBACvD;AAAA,YAAQ,QAAQ,gBAAAA,KAAC,SAAI,WAAU,wBAAwB,kBAAQ,MAAK;AAAA,IACrE,gBAAAA,KAAC,SAAI,WAAU,yBACX,0BAAQ,YAAR,mBAAiB,YAAW,CAAC,GAAG,IAAI,CAAC,WACrC,gBAAAA;AAAA,MAAC;AAAA;AAAA,QAEC,WAAU;AAAA,QACV,MAAK;AAAA,QACL,SAAS,MAAG;AA3DxB,cAAAC;AA2D2B,kBAAAA,MAAA,QAAQ,iBAAR,gBAAAA,IAAA,cAAuB,OAAO;AAAA;AAAA,QAE5C,iBAAO;AAAA;AAAA,MALH,GAAG,QAAQ,EAAE,IAAI,OAAO,KAAK;AAAA,IAMpC,CACD,GACH;AAAA,KACF;AAEJ;AAEA,IAAM,eAAgC,CAAC,YAAY;AACjD,QAAM,UAAU,QAAQ,WAAW,CAAC;AACpC,SACE,qBAAC,aAAQ,WAAU,WAAU,cAAY,QAAQ,SAAS,QAAQ,MAC/D;AAAA,YAAQ,YACP,gBAAAD,KAAC,SAAI,WAAU,iBACb,0BAAAA,KAAC,SAAI,KAAK,QAAQ,UAAU,KAAK,QAAQ,SAAS,cAAc,GAClE;AAAA,IAEF,qBAAC,SAAI,WAAU,mBACb;AAAA,sBAAAA,KAAC,QAAI,kBAAQ,SAAS,QAAQ,MAAK;AAAA,MAClC,QAAQ,QAAQ,gBAAAA,KAAC,OAAG,kBAAQ,MAAK;AAAA,MACjC,QAAQ,WACP,gBAAAA,KAAC,SAAI,WAAU,mBACZ,kBAAQ,QAAQ,IAAI,CAAC,WACpB,gBAAAA,KAAC,OAAqB,MAAM,OAAO,OAAO,KAAK,WAAU,gBACtD,iBAAO,SADF,OAAO,KAEf,CACD,GACH;AAAA,OAEJ;AAAA,KACF;AAEJ;AAEA,IAAM,kBAAmC,CAAC,YAAY;AACpD,QAAM,UAAU,QAAQ,WAAW,CAAC;AACpC,SACE,qBAAC,aAAQ,WAAU,WAAU,cAAY,QAAQ,SAAS,WACvD;AAAA,YAAQ,YACP,gBAAAA,KAAC,SAAI,WAAU,iBACb,0BAAAA,KAAC,SAAI,KAAK,QAAQ,UAAU,KAAK,QAAQ,SAAS,iBAAiB,GACrE;AAAA,IAEF,qBAAC,SAAI,WAAU,mBACb;AAAA,sBAAAA,KAAC,QAAI,kBAAQ,SAAS,QAAQ,MAAK;AAAA,MAClC,QAAQ,QAAQ,gBAAAA,KAAC,OAAG,kBAAQ,MAAK;AAAA,MACjC,QAAQ,WAAW,QAAQ,QAAQ,SAAS,KAC3C,gBAAAA,KAAC,SAAI,WAAU,mBACZ,kBAAQ,QAAQ,IAAI,CAAC,WACpB,gBAAAA,KAAC,OAAqB,MAAM,OAAO,OAAO,KAAK,WAAU,gBACtD,iBAAO,SADF,OAAO,KAEf,CACD,GACH;AAAA,OAEJ;AAAA,KACF;AAEJ;AAEA,IAAM,iBAAkC,CAAC,SAAS,YAAY;AAC5D,QAAM,UAAU,QAAQ,WAAW,CAAC;AACpC,SACE,qBAAC,SAAI,WAAU,aAAY,MAAK,QAAO,cAAY,QAAQ,SAAS,UAClE;AAAA,yBAAC,SAAI,WAAU,oBACb;AAAA,sBAAAA,KAAC,YAAQ,kBAAQ,SAAS,QAAQ,MAAK;AAAA,MACtC,QAAQ,QAAQ,gBAAAA,KAAC,OAAG,kBAAQ,MAAK;AAAA,OACpC;AAAA,IACA,gBAAAA,KAAC,SAAI,WAAU,qBAAoB,MAAK,SAAQ,cAAW,oBACvD,mBAAQ,WAAW,CAAC,GAAG,IAAI,CAAC,WAC5B,gBAAAA;AAAA,MAAC;AAAA;AAAA,QAEC,MAAK;AAAA,QACL,WAAU;AAAA,QACV,SAAS,MAAG;AAvIxB;AAuI2B,+BAAQ,iBAAR,iCAAuB,OAAO;AAAA;AAAA,QAE5C,iBAAO;AAAA;AAAA,MALH,OAAO;AAAA,IAMd,CACD,GACH;AAAA,KACF;AAEJ;AAEO,IAAM,yBAAyB,IAAI,yBAAyB;AACnE,uBAAuB,SAAS,iBAAiB,YAAY;AAC7D,uBAAuB,SAAS,QAAQ,YAAY;AACpD,uBAAuB,SAAS,WAAW,eAAe;AAC1D,uBAAuB,SAAS,UAAU,cAAc;AACxD,uBAAuB,SAAS,QAAQ,CAAC,QAAQ,gBAAAA,KAAC,UAAM,cAAI,MAAK,CAAO;;;ANsY9D,gBAAAE,MASI,QAAAC,aATJ;AApYV,IAAM,sBAAsB;AAM5B,SAAS,kBAA0B;AACjC,MAAI,OAAO,WAAW,eAAe,gBAAgB,QAAQ;AAC3D,WAAO,OAAO,WAAW;AAAA,EAC3B;AACA,SAAO,WAAW,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AACrE;AAKA,SAAS,uBAA+B;AACtC,MAAI;AACF,UAAM,WAAW,OAAO,aAAa,QAAQ,mBAAmB;AAChE,QAAI,SAAU,QAAO;AAErB,UAAM,QAAQ,gBAAgB;AAC9B,WAAO,aAAa,QAAQ,qBAAqB,KAAK;AACtD,WAAO;AAAA,EACT,QAAQ;AAEN,WAAO,gBAAgB;AAAA,EACzB;AACF;AAKO,IAAM,4BAET,CAAC;AAAA,EACH;AAAA,EACA,QAAQ;AAAA,EACR;AAAA,EACA,eAAe;AAAA;AAAA,EACf,cAAc;AAAA,EACd;AAAA,EACA,iBAAiB;AAAA,EACjB;AAAA,EACA,YAAY;AAAA,EACZ;AAAA,EACA,UAAU,CAAC;AAAA,EACX;AACF,MAAM;AACJ,QAAM,CAAC,QAAQ,SAAS,IAAI,SAAkB,WAAW;AACzD,QAAM,CAAC,WAAW,YAAY,IAAI,SAAwB,IAAI;AAC9D,QAAM,CAAC,UAAU,WAAW,IAAI,SAAwB,CAAC,CAAC;AAC1D,QAAM,CAAC,WAAW,YAAY,IAAI,SAAiB,EAAE;AACrD,QAAM,CAAC,WAAW,YAAY,IAAI,SAAkB,KAAK;AACzD,QAAM,CAAC,OAAO,QAAQ,IAAI,SAAwB,IAAI;AACtD,QAAM,CAAC,mBAAmB,oBAAoB,IAAI,SAA2B,IAAI;AACjF,QAAM,CAAC,iBAAiB,kBAAkB,IAAI,SAAyB,MAAM;AAC7E,QAAM,qBAAqBC;AAAA,IACzB,MAAM,oBAAoB,CAAC;AAAA,IAC3B,CAAC,gBAAgB;AAAA,EACnB;AACA,QAAM,WAAWA;AAAA,IACf,MAAM,mBAAmB;AAAA,IACzB,CAAC,eAAe;AAAA,EAClB;AACA,QAAM,iBAAiB,OAA8B,IAAI;AACzD,QAAM,eAAe,OAAgC,IAAI;AACzD,QAAM,eAAeA;AAAA,IACnB,MACE,IAAI,aAAa,SAAS;AAAA,MACxB;AAAA,MACA,WAAW,gCAAa;AAAA,MACxB,eAAe,OAAO,cAAc,WAAW,YAAY;AAAA,MAC3D;AAAA,MACA;AAAA,IACF,CAAC;AAAA,IACH,CAAC,OAAO;AAAA,EACV;AACA,QAAM,gBAAgBA;AAAA,IACpB,OAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,eAAe,OAAO,cAAc,WAAW,YAAY;AAAA,MAC3D;AAAA,MACA;AAAA,IACF;AAAA,IACA,CAAC,QAAQ,WAAW,WAAW,gBAAgB,MAAM;AAAA,EACvD;AAEA,YAAU,MAAM;AACd,iBAAa,cAAc;AAAA,MACzB;AAAA,MACA;AAAA,MACA,eAAe,OAAO,cAAc,WAAW,YAAY;AAAA,MAC3D;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH,GAAG,CAAC,cAAc,QAAQ,WAAW,WAAW,gBAAgB,MAAM,CAAC;AAEvE,YAAU,MAAM;AACd,SAAK,aAAa,KAAK;AACvB,SAAK,aAAa,YAAY;AAC9B,WAAO,MAAM;AACX,WAAK,aAAa,cAAc;AAAA,IAClC;AAAA,EACF,GAAG,CAAC,YAAY,CAAC;AAEjB,YAAU,MAAM;AACd,SAAK,aAAa,WAAW,MAAM;AAAA,EACrC,GAAG,CAAC,cAAc,MAAM,CAAC;AAKzB,YAAU,MAAM;AACd,UAAM,KAAK,qBAAqB;AAChC,iBAAa,EAAE;AAAA,EACjB,GAAG,CAAC,CAAC;AAOL,YAAU,MAAM;AACd,QAAI,CAAC,eAAgB;AACrB,QAAI,CAAC,UAAW;AAChB,QAAI,SAAS,SAAS,EAAG;AACzB,eAAW,OAAO,cAAc;AAAA,EAClC,GAAG,CAAC,gBAAgB,WAAW,SAAS,MAAM,CAAC;AAK/C,YAAU,MAAM;AACd,QAAI,eAAe,SAAS;AAC1B,qBAAe,QAAQ,eAAe,EAAE,UAAU,SAAS,CAAC;AAAA,IAC9D;AAAA,EACF,GAAG,CAAC,UAAU,MAAM,CAAC;AASrB,YAAU,MAAM;AACd,QAAI,CAAC,UAAW;AAChB,UAAM,cAAgC;AAAA,MACpC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,WAAW,yDAAoB;AAAA,MAC/B,SAAS,yDAAoB;AAAA,MAC7B,KAAK,yDAAoB;AAAA,IAC3B;AAEA,UAAM,iBAAiB,MAAiB;AAvT5C;AAwTM,UAAI,OAAO,cAAc,YAAY;AACnC,eAAO,UAAU,WAAW;AAAA,MAC9B;AACA,UAAI,cAAc,aAAa;AAC7B,YAAI;AACF,iBAAO,IAAI,mBAAmB;AAAA,YAC5B,GAAG;AAAA,YACH,GAAG;AAAA,UACL,CAA8B;AAAA,QAChC,SAAS,KAAK;AACZ,kBAAQ,KAAK,kDAAkD,GAAG;AAAA,QACpE;AAAA,MACF;AACA,aAAO,IAAI,iBAAiB;AAAA,QAC1B,GAAG;AAAA,QACH,GAAG;AAAA,QACH,iBAAgB,8DAAoB,mBAApB,YAAsC;AAAA,MACxD,CAA4B;AAAA,IAC9B;AAEA,UAAM,WAAW,eAAe;AAChC,aAAS,iBAAiB;AAAA,MACxB,QAAQ,MAAM;AACZ,2BAAmB,MAAM;AACzB,aAAK,aAAa,iBAAiB,EAAE,OAAO,OAAO,CAAC;AAAA,MACtD;AAAA,MACA,SAAS,CAAC,WAAW;AACnB,2BAAmB,QAAQ;AAC3B,aAAK,aAAa,iBAAiB,EAAE,OAAO,UAAU,OAAO,CAAC;AAC9D,YAAI,OAAQ,UAAS,sBAAsB,MAAM,EAAE;AAAA,MACrD;AAAA,MACA,SAAS,CAAC,QAAQ;AAChB,2BAAmB,OAAO;AAC1B,aAAK,aAAa,iBAAiB,EAAE,OAAO,SAAS,QAAQ,IAAI,QAAQ,CAAC;AAC1E,iBAAS,IAAI,OAAO;AAAA,MACtB;AAAA,MACA,WAAW,OAAO,aAAa;AAC7B,cAAM,OAAO,MAAM,QAAQ,QAAQ,IAAI,WAAW,CAAC,QAAQ;AAC3D,cAAM,YAAY,MAAM,aAAa,gBAAgB,IAAI;AACzD,oBAAY,CAAC,SAAS;AACpB,cAAI,MAAM,QAAQ,QAAQ,EAAG,QAAO;AACpC,iBAAO,CAAC,GAAG,MAAM,GAAG,SAAS;AAAA,QAC/B,CAAC;AAAA,MACH;AAAA,MACA,aAAa,CAAC,UAAU;AApW9B;AAqWQ,uEAAoB,QAApB,4CAA0B,mBAAmB;AAC7C,aAAK,aAAa,gBAAgB,KAAY;AAAA,MAChD;AAAA,IACF,CAAC;AACD,SAAK,SAAS,QAAQ;AACtB,SAAK,aAAa,iBAAiB,EAAE,OAAO,aAAa,CAAC;AAC1D,yBAAqB,QAAQ;AAE7B,WAAO,MAAM;AACX,WAAK,SAAS,WAAW,qBAAqB;AAAA,IAChD;AAAA,EACF,GAAG,CAAC,WAAW,QAAQ,gBAAgB,WAAW,gBAAgB,WAAW,kBAAkB,CAAC;AAKhG,QAAM,aAAa,CAAC,QAAoB,MAAc,UAAiC;AACrF,UAAM,aAA0B;AAAA,MAC9B,IAAI,GAAG,MAAM,IAAI,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AAAA,MAClE;AAAA,MACA;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,GAAG;AAAA,IACL;AACA,gBAAY,CAAC,SAAS,CAAC,GAAG,MAAM,UAAU,CAAC;AAAA,EAC7C;AAEA,QAAM,WAAW,OAAO,QAAgB;AACtC,QAAI,CAAC,IAAI,KAAK,KAAK,CAAC,aAAa,UAAW;AAE5C,UAAM,UAAU,IAAI,KAAK;AAGzB,eAAW,QAAQ,SAAS,EAAE,MAAM,OAAO,CAAC;AAC5C,iBAAa,EAAE;AACf,iBAAa,IAAI;AACjB,aAAS,IAAI;AAEb,QAAI;AACF,YAAM,UAA0B;AAAA,QAC9B;AAAA,QACA,SAAS;AAAA,QACT;AAAA,MACF;AAEA,YAAM,OAAO,MAAM,aAAa,KAAK,SAAS,eAAe;AAE7D,UAAI,6BAAM,OAAO;AACf,mBAAW,OAAO,KAAK,SAAS,qDAA2C,EAAE,MAAM,OAAO,CAAC;AAAA,MAC7F;AAAA,IACF,SAAS,KAAK;AACZ,cAAQ,MAAM,oBAAoB,GAAG;AACrC;AAAA,QACE;AAAA,MACF;AACA;AAAA,QACE;AAAA,QACA;AAAA,MACF;AAAA,IACF,UAAE;AACA,mBAAa,KAAK;AAAA,IACpB;AAAA,EACF;AAEA,QAAM,kBAAkB,OAAO,YAA6D;AAC1F,QAAI,mBAAmB;AACrB,aAAO,kBAAkB,KAAK,OAAO;AAAA,IACvC;AACA,UAAM,WAAW,MAAM,MAAM,QAAQ;AAAA,MACnC,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,MAClB;AAAA,MACA,MAAM,KAAK,UAAU,OAAO;AAAA,IAC9B,CAAC;AAED,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,IAAI,MAAM,kCAAkC,SAAS,MAAM,KAAK,SAAS,UAAU,EAAE;AAAA,IAC7F;AAEA,WAAQ,MAAM,SAAS,KAAK;AAAA,EAC9B;AAKA,QAAM,eAAe,OAAO,UAAqB;AAC/C,UAAM,eAAe;AACrB,QAAI,CAAC,UAAU,KAAK,KAAK,CAAC,aAAa,UAAW;AAClD,UAAM,UAAU;AAChB,UAAM,SAAS,OAAO;AAAA,EACxB;AAEA,QAAM,qBAAqB,OAAO,SAAsB;AAlc1D;AAmcI,QAAI,CAAC,QAAQ,CAAC,UAAW;AACzB,iBAAa,IAAI;AACjB,aAAS,IAAI;AACb,QAAI;AACF,UAAI,uDAAmB,UAAU;AAC/B,cAAM,WAAW,MAAM,kBAAkB,SAAS,MAAM;AAAA,UACtD,GAAI,kBAAkB,CAAC;AAAA,QACzB,CAAC;AACD,YAAI,UAAU;AACZ,sBAAY,CAAC,SAAS,CAAC,GAAG,MAAM,QAAQ,CAAC;AACzC;AAAA,QACF;AAAA,MACF;AAEA,YAAM,OAAO,IAAI,SAAS;AAC1B,WAAK,OAAO,aAAa,SAAS;AAClC,UAAI,gBAAgB;AAClB,mBAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,cAAc,GAAG;AACnD,eAAK,OAAO,QAAQ,CAAC,IAAI,OAAO,CAAC,CAAC;AAAA,QACpC;AAAA,MACF;AACA,WAAK,OAAO,QAAQ,MAAM,KAAK,IAAI;AAEnC,UAAI,SAAS;AACb,UAAI,CAAC,QAAQ;AACX,iBAAS,OAAO,SAAS,OAAO,IAC5B,OAAO,QAAQ,WAAW,SAAS,IACnC,OAAO,QAAQ,OAAO,EAAE,IAAI;AAAA,MAClC;AAEA,YAAM,OAAO,MAAM,MAAM,QAAS,EAAE,QAAQ,QAAQ,MAAM,KAAK,CAAC;AAChE,UAAI,CAAC,KAAK,GAAI,OAAM,IAAI,MAAM,kBAAkB,KAAK,MAAM,EAAE;AAC7D,UAAI;AACJ,UAAI;AACF,cAAM,OAAO,MAAM,KAAK,KAAK;AAC7B,mBAAU,wCAAM,UAAN,mBAAc,OAAd,mBAAkB;AAAA,MAC9B,QAAQ;AAAA,MAAC;AACT,YAAM,QAAQ,kBAAkB,KAAK,IAAI;AACzC,UAAI,SAAS;AACX,cAAM,UAAuB;AAAA,UAC3B,IAAI,QAAQ,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AAAA,UAC7D,QAAQ;AAAA,UACR,MAAM;AAAA,UACN,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UAClC;AAAA,UACA,UAAU,KAAK;AAAA,QACjB;AACA,oBAAY,CAAC,SAAS,CAAC,GAAG,MAAM,OAAO,CAAC;AAAA,MAC1C,OAAO;AACL,mBAAW,QAAQ,KAAK;AAAA,MAC1B;AAAA,IACF,SAAS,GAAG;AACV,cAAQ,MAAM,gBAAgB,CAAC;AAC/B,eAAS,iDAAiD;AAAA,IAC5D,UAAE;AACA,mBAAa,KAAK;AAClB,UAAI,aAAa,QAAS,cAAa,QAAQ,QAAQ;AAAA,IACzD;AAAA,EACF;AAEA,QAAM,mBAAmB,OAAO,UAAkB;AAChD,UAAM,SAAS,KAAK;AAAA,EACtB;AAKA,QAAM,iBAAiB,MAAM;AAC3B,QAAI,CAAC;AACH,aAAO;AACT,QAAI,eAAe,MAAO,QAAO,gBAAgB,eAAe,KAAK;AACrE,QAAI,eAAe,MAAO,QAAO,kBAAkB,eAAe,KAAK;AACvE,WAAO;AAAA,EACT;AAEA,SACE,gBAAAF,KAAC,kBAAe,SAAkB,SAAS,eAAe,QAAQ,cAChE,0BAAAC;AAAA,IAAC;AAAA;AAAA,MACC,WAAU;AAAA,MACV,OAAO,EAAE,CAAC,cAAqB,GAAG,aAAa;AAAA,MAG/C;AAAA,wBAAAD;AAAA,UAAC;AAAA;AAAA,YACC,MAAK;AAAA,YACL,WAAU;AAAA,YACV,SAAS,MAAM,UAAU,CAAC,SAAS,CAAC,IAAI;AAAA,YACxC,cAAY,SAAS,uBAAuB;AAAA,YAG5C,0BAAAA,KAAC,UAAK,WAAU,yBAAwB,eAAY,QAAO,uBAE3D;AAAA;AAAA,QACF;AAAA,QAGC,UACC,gBAAAC,MAAC,SAAI,WAAU,iBACb;AAAA,0BAAAA,MAAC,SAAI,WAAU,kBACb;AAAA,4BAAAA,MAAC,SAAI,WAAU,uBACb;AAAA,8BAAAD,KAAC,SAAI,WAAU,iBAAiB,iBAAM;AAAA,cACtC,gBAAAA,KAAC,SAAI,WAAU,oBAAoB,yBAAe,GAAE;AAAA,eACtD;AAAA,YACA,gBAAAA;AAAA,cAAC;AAAA;AAAA,gBACC,MAAK;AAAA,gBACL,WAAU;AAAA,gBACV,SAAS,MAAM,UAAU,KAAK;AAAA,gBAC9B,cAAW;AAAA,gBACZ;AAAA;AAAA,YAED;AAAA,aACF;AAAA,UAEA,gBAAAC,MAAC,SAAI,WAAU,gBAEZ;AAAA,qBAAS,gBAAAD,KAAC,SAAI,WAAU,iBAAiB,iBAAM;AAAA,YAGhD,gBAAAC,MAAC,SAAI,WAAU,oBACZ;AAAA,uBAAS,IAAI,CAAC,QACb,gBAAAD;AAAA,gBAAC;AAAA;AAAA,kBAEC,WAAW,oCAAoC,IAAI,MAAM;AAAA,kBAEzD,0BAAAA,KAAC,SAAI,WAAU,0BACZ,mBAAS,OAAO,KAAK,EAAE,cAAc,iBAAiB,CAAC,GAC1D;AAAA;AAAA,gBALK,IAAI;AAAA,cAMX,CACD;AAAA,cAGA,aACC,gBAAAA,KAAC,SAAI,WAAU,wCACb,0BAAAC,MAAC,SAAI,WAAU,mDACb;AAAA,gCAAAD,KAAC,UAAK,WAAU,UAAS;AAAA,gBACzB,gBAAAA,KAAC,UAAK,WAAU,UAAS;AAAA,gBACzB,gBAAAA,KAAC,UAAK,WAAU,UAAS;AAAA,iBAC3B,GACF;AAAA,cAGF,gBAAAA,KAAC,SAAI,KAAK,gBAAgB;AAAA,eAC5B;AAAA,aACF;AAAA,UAEA,gBAAAC,MAAC,UAAK,WAAU,qBAAoB,UAAU,cAC5C;AAAA,4BAAAD;AAAA,cAAC;AAAA;AAAA,gBACC,KAAK;AAAA,gBACL,MAAK;AAAA,gBACL,WAAU;AAAA,gBACV,cAAW;AAAA,gBACX,UAAU,CAAC,MAAG;AAzlB9B;AAylBiC,8CAAmB,OAAE,OAAO,UAAT,mBAAiB,OAAM,IAAI;AAAA;AAAA,gBAC/D,OAAO,EAAE,SAAS,OAAO;AAAA;AAAA,YAC3B;AAAA,YACA,gBAAAA;AAAA,cAAC;AAAA;AAAA,gBACC,MAAK;AAAA,gBACL,WAAU;AAAA,gBACV,SAAS,MAAG;AA/lB5B;AA+lB+B,4CAAa,YAAb,mBAAsB;AAAA;AAAA,gBACrC,UAAU,aAAa,CAAC;AAAA,gBACxB,cAAW;AAAA,gBACX,OAAM;AAAA,gBACP;AAAA;AAAA,YAED;AAAA,YACA,gBAAAA;AAAA,cAAC;AAAA;AAAA,gBACC,MAAK;AAAA,gBACL,WAAU;AAAA,gBACV,aAAY;AAAA,gBACZ,OAAO;AAAA,gBACP,UAAU,CAAC,MAAM,aAAa,EAAE,OAAO,KAAK;AAAA,gBAC5C,UAAU,aAAa,CAAC;AAAA;AAAA,YAC1B;AAAA,YACA,gBAAAA;AAAA,cAAC;AAAA;AAAA,gBACC,MAAK;AAAA,gBACL,WAAU;AAAA,gBACV,UAAU,aAAa,CAAC,aAAa,CAAC,UAAU,KAAK;AAAA,gBACtD;AAAA;AAAA,YAED;AAAA,aACF;AAAA,WACF;AAAA;AAAA;AAAA,EAEJ,GACF;AAEJ;;;AOznBA,SAAS,SAAS;AAChB,UAAO,oBAAI,KAAK,GAAE,YAAY;AAChC;AAMO,SAAS,oBAAoB,UAAgC,CAAC,GAAgB;AAVrF;AAWE,QAAM,UAAS,aAAQ,QAAR,aAAgB,CAAC,OAAO,WAAW,QAAQ,KAAK,UAAU,KAAK,KAAK,MAAM;AACzF,SAAO;AAAA,IACL,MAAM;AAAA,IACN,QAAQ,CAAC,QAAQ,OAAO,QAAQ,EAAE,IAAI,CAAC;AAAA,IACvC,cAAc,MAAM,OAAO,SAAS;AAAA,IACpC,eAAe,MAAM,OAAO,UAAU;AAAA,IACtC,mBAAmB,CAAC,SAAS,OAAO,cAAc,IAAI;AAAA,IACtD,cAAc,CAAC,YAAY;AACzB,aAAO,eAAe,EAAE,QAAQ,CAAC;AAAA,IACnC;AAAA,IACA,aAAa,CAAC,UAAU,aAAa,OAAO,cAAc,EAAE,SAAS,CAAC;AAAA,IACtE,YAAY,CAAC,aAAa;AACxB,aAAO,YAAY,EAAE,OAAO,SAAS,OAAO,CAAC;AAAA,IAC/C;AAAA,IACA,aAAa,CAAC,UAAU,OAAO,uBAAuB,KAAK;AAAA,IAC3D,aAAa,CAAC,UAAU;AACtB,aAAO,cAAc,EAAE,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,EAAE,CAAC;AAAA,IACxF;AAAA,EACF;AACF;AAMO,SAAS,oBAAoB,UAAgC,CAAC,GAAgB;AApCrF;AAqCE,QAAM,eAAc,aAAQ,mBAAR,aAA2B,MAAG;AArCpD,QAAAG,KAAA;AAqCuD,kBAAAA,MAAA,OAAO,eAAP,gBAAAA,IAAA,6BAAyB,SAAS,KAAK,IAAI,CAAC;AAAA;AACjG,SAAO;AAAA,IACL,MAAM;AAAA,IACN,cAAc,CAAC,SAAS,QAA0B;AAxCtD,UAAAA;AAyCM,YAAM,UAAU,YAAY;AAC5B,YAAM,WAAW,UAAU,OAAO;AAClC,eAAS,WAAW,EAAE,IAAIA,MAAA,SAAS,aAAT,OAAAA,MAAqB,CAAC,GAAI,SAAS,QAAQ,OAAO,EAAE;AAC9E,aAAO,EAAE,SAAS,SAAS;AAAA,IAC7B;AAAA,IACA,aAAa,CAAC,UAAU,WAAW,QAAQ;AACzC,cAAQ,MAAM,8BAA8B,IAAI,SAAS,EAAE;AAAA,IAC7D;AAAA,IACA,YAAY,CAAC,aAA4C;AACvD,aAAO,EAAE,UAAU,SAAS,IAAI,CAAC,OAAO,EAAE,GAAG,GAAG,UAAU,EAAE,GAAI,EAAU,SAAS,EAAE,EAAE,EAAE;AAAA,IAC3F;AAAA,EACF;AACF;AASO,SAAS,+BACd,SACa;AAhEf;AAiEE,QAAM,iBACJ,aAAQ,kBAAR,aAA0B,CAAC,UAAgB;AAlE/C,QAAAA;AAkEmD,YAAAA,MAAA,+BAAiB,YAAjB,gBAAAA,IAA0B,SAAS;AAAA;AACpF,MAAI,cAA6B;AAEjC,QAAM,cAAc,OAAO,YAA4C;AArEzE,QAAAA;AAsEI,QAAI,CAAC,aAAa;AAChB,oBAAc,MAAM,QAAQ,WAAW;AAAA,IACzC;AACA,UAAM,OAAO,UAAU,OAAO;AAC9B,SAAK,WAAW,EAAE,IAAIA,MAAA,KAAK,aAAL,OAAAA,MAAiB,CAAC,GAAI,WAAW,YAAY;AACnE,WAAO,EAAE,SAAS,KAAK;AAAA,EACzB;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,cAAc,CAAC,YAAY,YAAY,OAAO;AAAA,IAC9C,aAAa,OAAO,OAAO,YAAsC;AAjFrE,UAAAA;AAkFM,UAAI,CAAC,cAAc,KAAK,EAAG,QAAO,CAAC;AACnC,oBAAc,MAAM,QAAQ,WAAW;AACvC,YAAM,OAAO,UAAU,OAAO;AAC9B,WAAK,WAAW,EAAE,IAAIA,MAAA,KAAK,aAAL,OAAAA,MAAiB,CAAC,GAAI,WAAW,aAAa,aAAa,OAAO,EAAE;AAC1F,aAAO,EAAE,OAAO,MAAM,SAAS,MAAM,QAAQ,GAAG;AAAA,IAClD;AAAA,EACF;AACF;;;AC3EO,IAAM,0BAAN,MAA8B;AAAA,EAWnC,YAAY,SAAqC;AANjD,SAAiB,QAAQ,oBAAI,IAAwB;AACrD,SAAiB,WAAW,oBAAI,IAG9B;AAvBJ;AA0BI,SAAK,UAAU,QAAQ;AACvB,SAAK,WAAW,QAAQ;AACxB,SAAK,cAAa,aAAQ,eAAR,YAAsB;AACxC,SAAK,kBAAiB,aAAQ,mBAAR,YAA0B;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc,SAAiB,SAAuC;AApCxE;AAqCI,YAAO,UAAK,MAAM,IAAI,MAAM,MAArB,mBAAwB;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,SAAiB,SAAe;AACrC,UAAM,WAAW,KAAK,SAAS,IAAI,MAAM;AACzC,QAAI,UAAU;AACZ,eAAS,WAAW,MAAM;AAC1B,WAAK,SAAS,OAAO,MAAM;AAAA,IAC7B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAc;AACZ,SAAK,MAAM,MAAM;AACjB,SAAK,SAAS,QAAQ,CAAC,EAAE,WAAW,MAAM,WAAW,MAAM,CAAC;AAC5D,SAAK,SAAS,MAAM;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,UAAU,SAAiB,SAAS,QAAiD;AACzF,UAAM,WAAW,KAAK,MAAM,IAAI,MAAM;AACtC,QAAI,UAAU;AACZ,aAAO,EAAE,GAAG,SAAS,MAAM,eAAe,CAAC,GAAG,SAAS,KAAK,aAAa,EAAE;AAAA,IAC7E;AAEA,UAAM,WAAW,KAAK,SAAS,IAAI,MAAM;AACzC,QAAI,UAAU;AAGZ,UAAI,QAAQ;AACV,eAAO,iBAAiB,SAAS,MAAM,SAAS,WAAW,MAAM,GAAG,EAAE,MAAM,KAAK,CAAC;AAAA,MACpF;AACA,aAAO,SAAS;AAAA,IAClB;AAEA,UAAM,aAAa,IAAI,gBAAgB;AACvC,UAAM,eAAe,SACjB,KAAK,aAAa,QAAQ,WAAW,MAAM,IAC3C,WAAW;AAEf,UAAM,UAAU,KAAK,eAAe,QAAQ,YAAY,EACrD,KAAK,CAAC,SAAS;AACd,WAAK,MAAM,IAAI,QAAQ,EAAE,MAAM,WAAW,KAAK,IAAI,EAAE,CAAC;AACtD,WAAK,SAAS,OAAO,MAAM;AAC3B,aAAO,EAAE,GAAG,MAAM,eAAe,CAAC,GAAG,KAAK,aAAa,EAAE;AAAA,IAC3D,CAAC,EACA,MAAM,CAAC,QAAQ;AACd,WAAK,SAAS,OAAO,MAAM;AAC3B,YAAM;AAAA,IACR,CAAC;AAEH,SAAK,SAAS,IAAI,QAAQ,EAAE,YAAY,QAAQ,CAAC;AACjD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,aAAa,GAAgB,GAA6B;AAChE,QAAI,EAAE,QAAS,QAAO;AACtB,QAAI,EAAE,QAAS,QAAO;AAEtB,UAAM,aAAa,IAAI,gBAAgB;AAKvC,UAAM,QAAQ,MAAM,WAAW,MAAM;AACrC,MAAE,iBAAiB,SAAS,OAAO,EAAE,MAAM,KAAK,CAAC;AACjD,MAAE,iBAAiB,SAAS,OAAO,EAAE,MAAM,KAAK,CAAC;AAEjD,WAAO,WAAW;AAAA,EACpB;AAAA,EAEA,MAAc,eAAe,QAAgB,QAAgD;AA9H/F;AA+HI,QAAI,UAAU;AACd,QAAI;AAEJ,WAAO,WAAW,KAAK,YAAY;AACjC,UAAI;AACF,cAAM,MAAM,IAAI,IAAI,KAAK,SAAS,OAAO,SAAS,MAAM;AACxD,YAAI,WAAW,SAAS;AACtB,cAAI,aAAa,IAAI,UAAU,MAAM;AAAA,QACvC;AACA,YAAI,KAAK,UAAU;AACjB,cAAI,aAAa,IAAI,SAAS,OAAO,KAAK,QAAQ,CAAC;AAAA,QACrD;AAEA,cAAM,WAAW,MAAM,MAAM,IAAI,SAAS,GAAG,EAAE,OAAO,CAAC;AACvD,YAAI,CAAC,SAAS,IAAI;AAGhB,cAAI,SAAS,UAAU,OAAO,SAAS,WAAW,KAAK;AACrD,kBAAM,IAAI,eAAe,mBAAmB,SAAS,MAAM,EAAE;AAAA,UAC/D;AACA,gBAAM,IAAI,MAAM,iCAAiC,SAAS,MAAM,GAAG;AAAA,QACrE;AAEA,cAAM,UAA4B,MAAM,SAAS,KAAK;AAGtD,cAAM,iBAAgB,aAAQ,kBAAR,YAAyB,CAAC;AAChD,eAAO,EAAE,eAAe,YAAY,QAAQ,WAAW;AAAA,MACzD,SAAS,KAAK;AACZ,YAAI,OAAO,SAAS;AAClB,gBAAM,IAAI,MAAM,gCAAgC;AAAA,QAClD;AAEA,oBAAY;AACZ,cAAM,cACJ,eAAe,kBACd,eAAe,aAAa,UAAU,KAAK;AAE9C,YAAI,CAAC,eAAe,YAAY,KAAK,YAAY;AAC/C,gBAAM;AAAA,QACR;AAEA,cAAM,UAAU,KAAK,iBAAiB,KAAK;AAC3C,cAAM,KAAK,MAAM,SAAS,MAAM;AAChC,mBAAW;AAAA,MACb;AAAA,IACF;AAEA,UAAM,gCAAa,IAAI,MAAM,oCAAoC;AAAA,EACnE;AAAA,EAEQ,MAAM,IAAY,QAAoC;AAC5D,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,UAAU,OAAO,WAAW,MAAM;AACtC,eAAO,oBAAoB,SAAS,OAAO;AAC3C,gBAAQ;AAAA,MACV,GAAG,EAAE;AAEL,YAAM,UAAU,MAAM;AACpB,eAAO,aAAa,OAAO;AAC3B,eAAO,IAAI,MAAM,gCAAgC,CAAC;AAAA,MACpD;AAEA,aAAO,iBAAiB,SAAS,SAAS,EAAE,MAAM,KAAK,CAAC;AAAA,IAC1D,CAAC;AAAA,EACH;AACF;AAEA,IAAM,iBAAN,cAA6B,MAAM;AAAC;AAE7B,SAAS,kBAAkB,eAA6D;AAC7F,SAAO,CAAC,GAAG,aAAa,EAAE,KAAK,CAAC,GAAG,MAAO,EAAE,gBAAgB,EAAE,gBAAgB,KAAK,CAAE;AACvF;;;ACvMA,SAAgB,eAAAC,cAAa,WAAAC,UAAS,UAAAC,eAAc;;;ACApD,SAAS,aAAa,aAAAC,YAAW,WAAAC,UAAS,UAAAC,SAAQ,YAAAC,iBAAgB;AAiB3D,SAAS,oBACd,SACA,gBAAwB,SACxB;AACA,QAAM,CAAC,OAAO,QAAQ,IAAIA,UAAgC;AAAA,IACxD,OAAO,CAAC;AAAA,IACR,SAAS;AAAA,IACT,SAAS;AAAA,EACX,CAAC;AAED,QAAM,YAAYD,QAA2B,aAAa;AAC1D,QAAM,WAAWA,QAA+B,IAAI;AAEpD,QAAM,gBAAgBD;AAAA,IACpB,MAAM,MAAM,MAAM,QAAQ,CAAC,SAAS,KAAK,aAAa;AAAA,IACtD,CAAC,MAAM,KAAK;AAAA,EACd;AAEA,QAAM,WAAW;AAAA,IACf,OAAO,WAAoB;AAEzB,UAAI,MAAM,QAAS;AAEnB,YAAM,aAAa,IAAI,gBAAgB;AACvC,eAAS,UAAU;AAEnB,eAAS,CAAC,UAAU,EAAE,GAAG,MAAM,SAAS,MAAM,OAAO,OAAU,EAAE;AAEjE,UAAI;AACF,cAAM,OAAO,MAAM,QAAQ,UAAU,QAAQ,WAAW,MAAM;AAC9D,iBAAS,CAAC,SAAS;AACjB,gBAAM,QAAQ,WAAW,gBAAgB,CAAC,IAAI,IAAI,CAAC,GAAG,KAAK,OAAO,IAAI;AACtE,iBAAO;AAAA,YACL;AAAA,YACA,SAAS;AAAA,YACT,OAAO;AAAA,YACP,SAAS,QAAQ,KAAK,UAAU;AAAA,UAClC;AAAA,QACF,CAAC;AACD,kBAAU,UAAU,KAAK;AAAA,MAC3B,SAAS,KAAK;AACZ,YAAK,IAAc,QAAQ,SAAS,WAAW,GAAG;AAGhD;AAAA,QACF;AACA,iBAAS,CAAC,UAAU,EAAE,GAAG,MAAM,SAAS,OAAO,OAAO,IAAa,EAAE;AAAA,MACvE;AAAA,IACF;AAAA,IACA,CAAC,eAAe,SAAS,MAAM,OAAO;AAAA,EACxC;AAEA,EAAAD,WAAU,MAAM;AACd,aAAS,aAAa;AAEtB,WAAO,MAAM;AAxEjB;AAyEM,qBAAS,YAAT,mBAAkB;AAClB,cAAQ,OAAO,UAAU,OAAO;AAAA,IAClC;AAAA,EACF,GAAG,CAAC,eAAe,UAAU,OAAO,CAAC;AAErC,QAAM,WAAW,YAAY,MAAM;AACjC,QAAI,CAAC,MAAM,WAAW,MAAM,QAAS;AACrC,aAAS,UAAU,OAAO;AAAA,EAC5B,GAAG,CAAC,UAAU,MAAM,SAAS,MAAM,OAAO,CAAC;AAE3C,QAAM,QAAQ,YAAY,MAAM;AAnFlC;AAoFI,cAAS,eAAU,YAAV,YAAqB,aAAa;AAAA,EAC7C,GAAG,CAAC,eAAe,QAAQ,CAAC;AAE5B,SAAO;AAAA,IACL;AAAA,IACA,OAAO,MAAM;AAAA,IACb,SAAS,MAAM;AAAA,IACf,OAAO,MAAM;AAAA,IACb,SAAS,MAAM;AAAA,IACf;AAAA,IACA;AAAA,EACF;AACF;;;ADVU,SACE,OAAAI,MADF,QAAAC,aAAA;AAzEV,SAAS,gBAAgB,WAA2B;AAClD,QAAM,OAAO,IAAI,KAAK,SAAS;AAC/B,SAAO,KAAK,eAAe,QAAW;AAAA,IACpC,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,KAAK;AAAA,EACP,CAAC;AACH;AAEA,SAAS,cAAc,SAA0B;AAC/C,MAAI,CAAC,QAAS,QAAO;AACrB,SAAO,QAAQ,SAAS,KAAK,GAAG,QAAQ,MAAM,GAAG,EAAE,CAAC,QAAQ;AAC9D;AAQO,IAAM,sBAA0D,CAAC;AAAA,EACtE;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAAQ;AACV,MAAM;AACJ,QAAM,UAAUC,QAAgC,IAAI;AACpD,QAAM,EAAE,eAAe,SAAS,OAAO,SAAS,UAAU,MAAM,IAAI;AAAA,IAClE;AAAA,EACF;AAEA,QAAM,SAASC,SAAQ,MAAM,kBAAkB,aAAa,GAAG,CAAC,aAAa,CAAC;AAE9E,QAAM,eAAeC,aAAY,MAAM;AACrC,UAAM,OAAO,QAAQ;AACrB,QAAI,CAAC,QAAQ,CAAC,WAAW,QAAS;AAElC,UAAM,mBAAmB,KAAK,eAAe,KAAK,YAAY,KAAK;AACnE,QAAI,mBAAmB,IAAI;AACzB,eAAS;AAAA,IACX;AAAA,EACF,GAAG,CAAC,SAAS,UAAU,OAAO,CAAC;AAE/B,QAAM,gBAAgBA;AAAA,IACpB,CAAC,OAA+C,UAAkB;AAChE,UAAI,CAAC,QAAQ,QAAS;AAEtB,YAAM,WAAW,QAAQ,QAAQ,iBAAoC,uBAAuB;AAC5F,YAAM,cAAc,MAAM,QAAQ,cAAc,QAAQ,IAAI,MAAM,QAAQ,YAAY,QAAQ,IAAI;AAClG,UAAI,cAAc,KAAK,eAAe,SAAS,OAAQ;AACvD,eAAS,WAAW,EAAE,MAAM;AAC5B,YAAM,eAAe;AAAA,IACvB;AAAA,IACA,CAAC;AAAA,EACH;AAEA,QAAM,aAAa,CAAC,cAAmC,UAAkB;AACvE,UAAM,aAAa,aAAa,OAAO;AACvC,WACE,gBAAAJ,KAAC,QAAyB,WAAU,kBAClC,0BAAAC;AAAA,MAAC;AAAA;AAAA,QACC,MAAK;AAAA,QACL,MAAK;AAAA,QACL,iBAAe;AAAA,QACf,WAAW,mBAAmB,aAAa,4BAA4B,EAAE;AAAA,QACzE,SAAS,MAAM,6DAAuB,aAAa;AAAA,QACnD,WAAW,CAAC,UAAU;AACpB,cAAI,MAAM,QAAQ,eAAe,MAAM,QAAQ,WAAW;AACxD,0BAAc,OAAO,KAAK;AAAA,UAC5B;AAAA,QACF;AAAA,QAEA;AAAA,0BAAAA,MAAC,SAAI,WAAU,2BACb;AAAA,4BAAAD,KAAC,UAAK,WAAU,0BAA0B,uBAAa,OAAM;AAAA,YAC7D,gBAAAA,KAAC,UAAK,WAAU,8BAA6B,cAAW,gBACrD,0BAAgB,aAAa,aAAa,GAC7C;AAAA,aACF;AAAA,UACA,gBAAAC,MAAC,SAAI,WAAU,yBACb;AAAA,4BAAAD,KAAC,UAAK,WAAU,4BAA4B,wBAAc,aAAa,kBAAkB,GAAE;AAAA,YAC1F,aAAa,SAAS,gBAAAA,KAAC,UAAK,WAAU,2BAA0B,cAAW,UAAS,IAAK;AAAA,aAC5F;AAAA,UACC,aAAa,mBACZ,gBAAAA,KAAC,UAAK,WAAU,gCAAgC,uBAAa,kBAAiB,IAC5E;AAAA;AAAA;AAAA,IACN,KA1BO,aAAa,EA2BtB;AAAA,EAEJ;AAEA,SACE,gBAAAC,MAAC,WAAM,WAAU,cAAa,cAAW,qBACvC;AAAA,oBAAAA,MAAC,SAAI,WAAU,sBACb;AAAA,sBAAAD,KAAC,QAAG,WAAU,qBAAqB,iBAAM;AAAA,MACxC,UAAU,gBAAAA,KAAC,UAAK,WAAU,uBAAsB,aAAU,UAAS,2BAAQ,IAAU;AAAA,OACxF;AAAA,IACC,QACC,gBAAAC,MAAC,SAAI,WAAU,qBAAoB,MAAK,SACtC;AAAA,sBAAAD,KAAC,OAAE,4DAA8C;AAAA,MACjD,gBAAAA,KAAC,YAAO,MAAK,UAAS,SAAS,OAAO,WAAU,qBAAoB,mBAEpE;AAAA,OACF,IACE;AAAA,IACJ,gBAAAC;AAAA,MAAC;AAAA;AAAA,QACC,KAAK;AAAA,QACL,WAAU;AAAA,QACV,MAAK;AAAA,QACL,cAAW;AAAA,QACX,UAAU;AAAA,QACV,UAAU;AAAA,QAET;AAAA,iBAAO,IAAI,CAAC,cAAc,UAAU,WAAW,cAAc,KAAK,CAAC;AAAA,UACnE,CAAC,WAAW,OAAO,WAAW,KAAK,CAAC,QACnC,gBAAAD,KAAC,QAAG,WAAU,qBAAoB,mCAAqB,IACrD;AAAA,UACH,UAAU,gBAAAA,KAAC,QAAG,WAAU,uBAAsB,yCAAsB,IAAQ;AAAA;AAAA;AAAA,IAC/E;AAAA,IACC,WAAW,CAAC,UACX,gBAAAA,KAAC,YAAO,MAAK,UAAS,WAAU,yBAAwB,SAAS,UAAU,uBAE3E,IACE;AAAA,KACN;AAEJ;","names":["useMemo","jsx","_a","jsx","jsxs","useMemo","_a","useCallback","useMemo","useRef","useEffect","useMemo","useRef","useState","jsx","jsxs","useRef","useMemo","useCallback"]}