#!/usr/bin/env node
import fs from 'node:fs/promises'
import path from 'node:path'
import crypto from 'node:crypto'

/**
 * Options accepted by the generator. Defaults are intentionally production biased
 * so new stacks always start with auth, durable storage, and CORS guards.
 */
export type CreateBaconAppOptions = {
  targetDir: string
  appName?: string
  withRedis?: boolean
  force?: boolean
}

/**
 * Resolve a path in a cross-platform way and ensure parent directories exist.
 */
async function writeFileRecursive(filePath: string, contents: string, force = false) {
  await fs.mkdir(path.dirname(filePath), { recursive: true })
  const exists = await fs
    .access(filePath)
    .then(() => true)
    .catch(() => false)
  if (exists && !force) {
    throw new Error(`Refusing to overwrite existing file at ${filePath}. Pass --force to replace.`)
  }
  await fs.writeFile(filePath, contents)
}

function randomSecret(): string {
  return crypto.randomBytes(24).toString('hex')
}

function envTemplate(appName: string, withRedis: boolean) {
  const redisLine = withRedis ? 'REDIS_URL=redis://redis:6379' : '# REDIS_URL=redis://redis:6379'
  return `# Environment template generated by create-bacon-app
PORT=3001
HOST=0.0.0.0
BASE_URL=http://localhost:3001
DATABASE_URL=postgres://bacon:changeme@db:5432/${appName}
${redisLine}
JWT_SECRET=${randomSecret()}
BEARER_TOKEN=admin-${randomSecret().slice(0, 12)}
GROK_API_KEY=replace-with-provider-key
ALLOWED_ORIGINS=localhost:4173,localhost:5173
ENABLE_WEBSOCKET=true
ENABLE_HTTP_POLLING=true
`
}

function dockerComposeTemplate(appName: string, withRedis: boolean) {
  const redisService = withRedis
    ? `  redis:
    image: redis:7-alpine
    container_name: ${appName}-redis
    command: ["redis-server", "--save", "", "--appendonly", "no"]
    profiles: ["redis"]
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
`
    : ''

  const redisDepends = withRedis ? '      redis:\n        condition: service_started\n' : ''

  return `version: '3.9'

services:
  backend:
    build:
      context: .
      dockerfile: Dockerfile
    env_file:
      - .env
    environment:
      PORT: \${PORT:-3001}
      HOST: 0.0.0.0
      BASE_URL: \${BASE_URL:-http://localhost:3001}
      DATABASE_URL: \${DATABASE_URL:-postgres://bacon:changeme@db:5432/${appName}}
      REDIS_URL: \${REDIS_URL:-redis://redis:6379}
      JWT_SECRET: \${JWT_SECRET:-${randomSecret()}}
      BEARER_TOKEN: \${BEARER_TOKEN:-}
      GROK_API_KEY: \${GROK_API_KEY:-}
      ALLOWED_ORIGINS: \${ALLOWED_ORIGINS:-localhost:4173,localhost:5173}
    ports:
      - "\${PORT:-3001}:3001"
    depends_on:
      db:
        condition: service_healthy
${redisDepends}    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:3001/readyz"]
      interval: 20s
      timeout: 5s
      retries: 5
      start_period: 10s

  admin:
    build:
      context: .
      dockerfile: ops/Dockerfile.admin
    env_file:
      - .env
    depends_on:
      backend:
        condition: service_healthy
    ports:
      - "\${ADMIN_PORT:-4173}:4173"

  db:
    image: postgres:16-alpine
    container_name: ${appName}-pg
    environment:
      POSTGRES_USER: bacon
      POSTGRES_PASSWORD: changeme
      POSTGRES_DB: ${appName}
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER"]
      interval: 10s
      timeout: 5s
      retries: 5
${redisService}volumes:
  pgdata:
`
}

function backendConfigTemplate(appName: string) {
  return `// Generated by create-bacon-app to centralize all backend wiring.
import path from 'node:path'
import dotenv from 'dotenv'
import { createBaconServer, MemoryStorage, PostgresStorage } from 'bacon-backend'

dotenv.config({ path: path.join(process.cwd(), '.env') })

const uploadsDir = path.join(process.cwd(), '.data/uploads')

export function createBackend() {
  const storage = process.env.DATABASE_URL
    ? new PostgresStorage({ connectionString: process.env.DATABASE_URL } as any)
    : new MemoryStorage()

  const server = createBaconServer({
    storage,
    fileHandling: { uploadsDir },
    auth: { bearerToken: process.env.BEARER_TOKEN, jwtSecret: process.env.JWT_SECRET },
    transports: {
      enableHttpPolling: process.env.ENABLE_HTTP_POLLING !== 'false',
      enableWebSocket: process.env.ENABLE_WEBSOCKET !== 'false',
    },
    settings: {
      general: { title: '${appName} Support', defaultOpen: true, welcomeMessage: 'How can we help?' },
      branding: { primaryColor: '#2563eb', customCss: '' },
      behavior: { replyDelayMs: 0, maxHistory: 200, retentionDays: 30 },
      transports: { default: 'polling', allowPolling: true, allowWebSocket: true, webSocketPath: '/api/chat/ws' },
      plugins: { logging: true, tracing: false, authTokenRefresher: false },
      integrations: { apiUrl: '/api/chat', apiAuthHeader: '' },
      security: { allowedOrigins: process.env.ALLOWED_ORIGINS?.split(',') || ['*'] },
      ai: { provider: 'echo', systemPrompt: 'You are a helpful agent.' },
    },
  })

  return server
}
`
}

function nextAppTemplate(appName: string) {
  return `import type { AppProps } from 'next/app'
import '../styles.css'

export default function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}
`
}

function nextPageTemplate(appName: string) {
  return `import Head from 'next/head'
import dynamic from 'next/dynamic'
import React from 'react'

const CustomerSupportChatWidget = dynamic(
  () => import('customer-support-chat-widget').then((m) => m.CustomerSupportChatWidget),
  { ssr: false },
)

export default function Home() {
  return (
    <>
      <Head>
        <title>${appName} Support</title>
      </Head>
      <main className="page">
        <h1>${appName} Support Desk</h1>
        <p>
          The widget below is wired to the backend generated by <code>create-bacon-app</code>.
          Auth, persistence, and transports are driven by your <code>.env</code> file so CI can
          spin up the same stack without extra glue.
        </p>
        <CustomerSupportChatWidget
          apiUrl="/api/chat"
          title="${appName} Support"
          primaryColor="#2563eb"
          transport="websocket"
          transportOptions={{ webSocketUrl: '/api/chat/ws' }}
          userIdentifier={{ email: 'ci@example.com' }}
        />
      </main>
    </>
  )
}
`
}

function nextStylesTemplate() {
  return `:root {
  --page-bg: #0f172a;
  --page-text: #e2e8f0;
}

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: var(--page-bg);
  color: var(--page-text);
}

main.page {
  min-height: 100vh;
  padding: 3rem;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

code {
  background: rgba(148, 163, 184, 0.15);
  padding: 0.2rem 0.35rem;
  border-radius: 6px;
}
`
}

function nextPackageTemplate(appName: string) {
  return `{
  "name": "${appName}-next-app",
  "private": true,
  "version": "0.1.0",
  "scripts": {
    "dev": "next dev -H 0.0.0.0 -p 4173",
    "build": "next build",
    "start": "next start -H 0.0.0.0 -p 4173"
  },
  "dependencies": {
    "customer-support-chat-widget": "^0.1.0",
    "next": "^14.2.7",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "typescript": "^5.6.3"
  }
}
`
}

function automationScriptTemplate() {
  return `#!/usr/bin/env bash
set -euo pipefail

# One-shot bootstrap used by CI and onboarding docs. It copies env defaults,
# installs the Next.js frontend dependencies, and builds the docker images.
if [ ! -f .env ]; then
  cp .env.example .env
fi

echo "[setup] installing frontend dependencies"
npm install --prefix frontend/next-app

echo "[setup] building Next.js app for production"
npm run build --prefix frontend/next-app

echo "[setup] building docker images"
docker compose build

echo "[setup] bringing stack online"
docker compose up -d
`
}

function workspaceReadmeTemplate(appName: string) {
  return `# ${appName} stack

This workspace was generated by create-bacon-app to minimize manual steps
when standing up a bacon-backend + chat widget stack. The defaults are tuned for
containerized CI smoke tests and local dev.

## Quick start

1. Run "cp .env.example .env" and adjust secrets.
2. Run "npm install --prefix frontend/next-app".
3. Run "npm run build --prefix frontend/next-app".
4. Run "docker compose up --build" (or "make stack-up").

## Layout

- .env.example – env contract for backend + admin.
- docker-compose.yml – backend, admin (static), Postgres, optional Redis.
- backend/config.ts – backend factory wired to env + Postgres.
- frontend/next-app – Next.js host embedding the widget.
- scripts/bootstrap.sh – automated installer/build/stack bring-up.

## Troubleshooting

- Postgres failures: ensure volume permissions allow container writes and the
  password in DATABASE_URL matches POSTGRES_PASSWORD in compose.
- Admin not reachable: check "docker compose ps" and make sure the admin image
  built successfully (uses Vite preview under the hood).
- CORS blocked: tighten ALLOWED_ORIGINS and restart backend to pick up
  changes.

## Scaling notes

- Backend is stateless when using Postgres, so run multiple replicas behind a
  load balancer and enable sticky sessions if WebSockets are in use.
- Swap Redis into your profile (STACK_PROFILES=redis make stack-up) to offload
  rate limiting or future queue-based workflows.
- Secrets should be injected via your orchestrator (K8s/Swarm) rather than baked
  into images; this template keeps them in .env for local-only ease.
`
}

/**
 * Generate the project scaffold in-memory and write it to disk.
 */
export async function createBaconApp(options: CreateBaconAppOptions) {
  const appName = options.appName || 'bacon'
  const target = path.resolve(options.targetDir)
  const files: Record<string, string> = {
    '.env.example': envTemplate(appName, options.withRedis ?? true),
    'docker-compose.yml': dockerComposeTemplate(appName, options.withRedis ?? true),
    'backend/config.ts': backendConfigTemplate(appName),
    'frontend/next-app/package.json': nextPackageTemplate(appName),
    'frontend/next-app/pages/_app.tsx': nextAppTemplate(appName),
    'frontend/next-app/pages/index.tsx': nextPageTemplate(appName),
    'frontend/next-app/styles.css': nextStylesTemplate(),
    'scripts/bootstrap.sh': automationScriptTemplate(),
    'README.md': workspaceReadmeTemplate(appName),
  }

  for (const [relative, contents] of Object.entries(files)) {
    const fullPath = path.join(target, relative)
    await writeFileRecursive(fullPath, contents, options.force)
  }

  return { target, files: Object.keys(files) }
}

function parseArgs(argv: string[]): CreateBaconAppOptions {
  const options: CreateBaconAppOptions = { targetDir: path.join(process.cwd(), 'bacon-stack') }
  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i]
    if (arg === '--dir' || arg === '-d') {
      options.targetDir = argv[++i] || options.targetDir
    } else if (arg === '--name' || arg === '-n') {
      options.appName = argv[++i]
    } else if (arg === '--no-redis') {
      options.withRedis = false
    } else if (arg === '--force') {
      options.force = true
    }
  }
  return options
}

async function main() {
  const options = parseArgs(process.argv.slice(2))
  const result = await createBaconApp(options)
  const relativeFiles = result.files.map((file) => path.relative(process.cwd(), path.join(result.target, file)))
  console.log('[create-bacon-app] scaffolded files:')
  for (const file of relativeFiles) {
    console.log(`- ${file}`)
  }
  console.log(`\nNext steps:\n  cd ${path.relative(process.cwd(), result.target)}\n  bash scripts/bootstrap.sh\n  docker compose ps`)
}

if (require.main === module) {
  main().catch((err) => {
    console.error('[create-bacon-app] failed to scaffold project:', err)
    process.exit(1)
  })
}
